
================================================================
File Summary
================================================================


File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line


================================================================
Repository Structure
================================================================
src/
  app/
    (auth)/
      sign-in/
        [[...sign-in]]/
          page.tsx
      sign-up/
        [[...sign-up]]/
          page.tsx
      layout.tsx
    (dashboard)/
      calendar/
        page.tsx
      dashboard/
        page.tsx
      events/
        [eventId]/
          edit/
            page.tsx
          loading.tsx
          page.tsx
        new/
          page.tsx
        loading.tsx
        page.tsx
      settings/
        subscription/
          page.tsx
      layout.tsx
    api/
      activities/
        route.ts
      events/
        [eventId]/
          activities/
            route.ts
          chat/
            [messageId]/
              route.ts
            route.ts
          check-in/
            route.ts
          export/
            route.ts
          guests/
            [guestId]/
              route.ts
            route.ts
          invite/
            route.ts
          stats/
            route.ts
          waitlist/
            route.ts
          route.ts
        recurring/
          route.ts
        stats/
          charts/
            route.ts
        upcoming/
          route.ts
        route.ts
      sentry-example-api/
        route.ts
      subscriptions/
        checkout/
          route.ts
        create-checkout/
          route.ts
        portal/
          route.ts
        route.ts
      users/
        [userId]/
          route.ts
      webhooks/
        clerk/
          route.ts
        stripe/
          route.ts
      mocks.ts
    sentry-example-page/
      page.tsx
    error.tsx
    global-error.tsx
    globals.css
    layout.tsx
    not-found.tsx
    page.tsx
    sentry.client.config.ts
  components/
    activity/
      activity-feed.tsx
    ads/
      AdSense.tsx
      AdUnit.tsx
    calendar/
      event-calendar.tsx
    dashboard/
      charts.tsx
      event-stats.tsx
      metric-card.tsx
      metrics.tsx
      recent-activity.tsx
      upcoming-events.tsx
    error-boundary/
      global-error.tsx
      sentry-error-boundary.tsx
      with-error-boundary.tsx
    events/
      check-in.tsx
      event-card.tsx
      event-chat.tsx
      event-form.tsx
      guest-list.tsx
      share-event.tsx
      venue-map.tsx
    export/
      export-button.tsx
    filters/
      advanced-filter.tsx
    layout/
      event-card.tsx
      main-nav.tsx
      navbar.tsx
    providers/
      theme-provider.tsx
    subscription/
      feature-gate.tsx
      pricing-table.tsx
      subscribe-button.tsx
      subscription-content.tsx
      subscription-plans.tsx
      SubscriptionProvider.tsx
    ui/
      a11y-announcer.tsx
      avatar.tsx
      badge.tsx
      button.tsx
      calendar.tsx
      card.tsx
      date-picker.tsx
      dialog.tsx
      dropdown-menu.tsx
      form.tsx
      icons.tsx
      input.tsx
      label.tsx
      loading-state.tsx
      popover.tsx
      progress.tsx
      radio-group.tsx
      scroll-area.tsx
      select.tsx
      separator.tsx
      sheet.tsx
      skeleton.tsx
      switch.tsx
      table.tsx
      tabs.tsx
      textarea.tsx
      toast.tsx
      toaster.tsx
      tooltip.tsx
    mode-toggle.tsx
  emails/
    event-invitation.tsx
  hooks/
    use-error-boundary.ts
    use-feature-access.ts
    use-subscription.ts
    use-toast.ts
  lib/
    actions/
      events.ts
    activity/
      notifications.ts
    api/
      error-handler.ts
    auth/
      rate-limit.ts
      rbac.ts
      roles.ts
      types.ts
    constants/
      event-categories.ts
    db/
      models/
        activity.ts
        event.ts
        guest.ts
        message.ts
        subscription.ts
        user.model.ts
        waitlist.ts
      utils/
        monitor.ts
        performance.ts
      connection.ts
    email/
      notifications.ts
    export/
      index.ts
    subscription/
      feature-gates.ts
      subscription-service.ts
      usage-tracking.ts
      webhooks.ts
    validation/
      event.ts
      sanitize.ts
    auth.ts
    google-calendar.ts
    logger.ts
    pusher.ts
    rate-limit.ts
    stripe.ts
    utils.ts
  mocks/
    browser.ts
    handlers.ts
    server.ts
  types/
    event.ts
    subscription.ts
  instrumentation.ts
  middleware.ts
.env.example
.gitignore
components.json
jest.config.ts
jest.setup.ts
next.config.mjs
package.json
postcss.config.mjs
sentry.client.config.ts
sentry.edge.config.ts
sentry.server.config.ts
service-worker.js
tailwind.config.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: src/app/(auth)/sign-in/[[...sign-in]]/page.tsx
================
import { SignIn } from "@clerk/nextjs";

export default function SignInPage() {
  return (
    <div className="flex h-screen items-center justify-center">
      <SignIn 
        appearance={{
          elements: {
            formButtonPrimary: 'bg-primary text-primary-foreground hover:bg-primary/90',
            footerActionLink: 'text-primary hover:text-primary/90'
          }
        }}
      />
    </div>
  );
}

================
File: src/app/(auth)/sign-up/[[...sign-up]]/page.tsx
================
import { SignUp } from "@clerk/nextjs";

export default function SignUpPage() {
  return (
    <div className="flex h-screen items-center justify-center">
      <SignUp 
        appearance={{
          elements: {
            formButtonPrimary: 'bg-primary text-primary-foreground hover:bg-primary/90',
            footerActionLink: 'text-primary hover:text-primary/90'
          }
        }}
      />
    </div>
  );
}

================
File: src/app/(auth)/layout.tsx
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";

export default async function AuthLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const { userId } = await auth();

  // If user is already authenticated, redirect to dashboard
  if (userId) {
    redirect("/dashboard");
  }

  return (
    <div className="flex h-screen items-center justify-center">
      {children}
    </div>
  );
}

================
File: src/app/(dashboard)/calendar/page.tsx
================
import { EventCalendar } from "@/components/calendar/event-calendar";

export default function CalendarPage() {
  return (
    <div className="space-y-4">
      <h1 className="text-3xl font-bold">Calendar</h1>
      <EventCalendar />
    </div>
  );
}

================
File: src/app/(dashboard)/dashboard/page.tsx
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { DashboardCharts } from "@/components/dashboard/charts";
import { UpcomingEvents } from "@/components/dashboard/upcoming-events";
import { EventStats } from "@/components/dashboard/event-stats";
import { RecentActivity } from "@/components/dashboard/recent-activity";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import AdUnit from "@/components/ads/AdUnit";
import { FeatureGate } from "@/components/subscription/feature-gate";
import { FEATURES } from "@/types/subscription";
import { getCurrentSubscription } from "@/lib/subscription/subscription-service";
import { Button } from "@/components/ui/button";
import Link from "next/link";

async function getEventStats(userId: string) {
  await dbConnect();

  const now = new Date();
  const thirtyDaysFromNow = new Date();
  thirtyDaysFromNow.setDate(now.getDate() + 30);

  try {
    // Get user's events first to avoid multiple queries
    const userEvents = await Event.find({ organizerId: userId }).select('_id');
    const eventIds = userEvents.map(event => event._id);

    const [totalEvents, upcomingEvents, totalAttendees, checkedInAttendees] = await Promise.all([
      // Total events (use cached result)
      Promise.resolve(userEvents.length),
      
      // Upcoming events (next 30 days)
      Event.countDocuments({
        _id: { $in: eventIds },
        startDate: { $gte: now, $lte: thirtyDaysFromNow }
      }),
      
      // Total confirmed attendees across all events
      Guest.countDocuments({
        eventId: { $in: eventIds },
        status: "confirmed"
      }),
      
      // Total checked-in attendees
      Guest.countDocuments({
        eventId: { $in: eventIds },
        checkedIn: true
      })
    ]);

    const averageAttendance = totalAttendees > 0 
      ? Math.round((checkedInAttendees / totalAttendees) * 100)
      : 0;

    return {
      totalEvents,
      upcomingEvents,
      totalAttendees,
      averageAttendance
    };
  } catch (error) {
    console.error("Error fetching event stats:", error);
    return {
      totalEvents: 0,
      upcomingEvents: 0,
      totalAttendees: 0,
      averageAttendance: 0
    };
  }
}

export default async function DashboardPage() {
  const { userId } = await auth();
  if (!userId) redirect("/sign-in");

  const [stats, subscription] = await Promise.all([
    getEventStats(userId),
    getCurrentSubscription(userId)
  ]);

  const hasReachedEventLimit = subscription.usage.eventsCreated >= subscription.limits.maxEvents;

  return (
    <div className="flex gap-4">
      {/* Main Dashboard Content */}
      <div className="flex-1 space-y-8 p-6">
        <div className="flex items-center justify-between">
          <h1 className="text-3xl font-bold">Dashboard</h1>
          {hasReachedEventLimit ? (
            <Button asChild variant="outline">
              <Link href="/settings/subscription">
                Upgrade Plan
              </Link>
            </Button>
          ) : (
            <Button asChild>
              <Link href="/events/new">Create Event</Link>
            </Button>
          )}
        </div>

        {/* Stats Grid */}
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
          <EventStats 
            stats={stats} 
            limits={{
              maxEvents: subscription.limits.maxEvents,
              maxGuests: subscription.limits.maxGuestsPerEvent
            }}
          />
        </div>

        {/* Main Content Grid */}
        <div className="grid gap-8">
          {/* Upcoming Events Section */}
          <div className="w-full">
            <UpcomingEvents maxEvents={subscription.limits.maxEvents} />
          </div>

          {/* Analytics Section */}
          <div className="grid gap-6 md:grid-cols-2">
            {/* Basic Analytics */}
            <FeatureGate 
              feature={FEATURES.BASIC_ANALYTICS}
              fallback={
                <Card className="p-8 text-center">
                  <h3 className="font-semibold">Analytics</h3>
                  <p className="text-sm text-muted-foreground mt-2">
                    Upgrade to view event analytics
                  </p>
                  <Button asChild className="mt-4" variant="outline">
                    <Link href="/settings/subscription">Upgrade Now</Link>
                  </Button>
                </Card>
              }
            >
              <Card>
                <CardHeader>
                  <CardTitle>Recent Activity</CardTitle>
                </CardHeader>
                <CardContent>
                  <RecentActivity />
                </CardContent>
              </Card>
            </FeatureGate>

            {/* Charts Section */}
            <div className="space-y-6">
              {/* Advanced Analytics */}
              <FeatureGate 
                feature={FEATURES.ADVANCED_ANALYTICS}
                fallback={
                  <Card className="p-8 text-center">
                    <h3 className="font-semibold">Advanced Analytics</h3>
                    <p className="text-sm text-muted-foreground mt-2">
                      Upgrade to access detailed analytics and insights
                    </p>
                    <Button asChild className="mt-4" variant="outline">
                      <Link href="/settings/subscription">Upgrade Now</Link>
                    </Button>
                  </Card>
                }
              >
                <DashboardCharts />
              </FeatureGate>
            </div>
          </div>
        </div>

        {/* Advertisement Section */}
        <div className="hidden xl:block">
          <AdUnit 
            slot="30002"
            format="vertical"
            style={{ 
              position: "sticky",
              top: "2rem",
              minHeight: "100px",
              maxWidth: "400px",
              margin: "0 auto",
              display: "flex",
              justifyContent: "center"
            }}
          />
        </div>
      </div>      
    </div>
  );
}

================
File: src/app/(dashboard)/events/[eventId]/edit/page.tsx
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { Card } from "@/components/ui/card";
import { EventForm } from "@/components/events/event-form";
import { Event } from "@/lib/db/models/event";
import dbConnect from "@/lib/db/connection";

async function getEvent(eventId: string) {
  try {
    await dbConnect();
    const event = await Event.findById(eventId).toString();
    if (!event) return null;
    return event;
  } catch (error) {
    console.error("Error fetching event:", error);
    return null;
  }
}

export default async function EditEventPage({
  params,
}: {
  params: { eventId: string };
}) {
  const { userId } = await auth();
  if (!userId) {
    redirect("/sign-in");
  }

  const event = await getEvent(params.eventId);
  if (!event) {
    redirect("/events");
  }

  return (
    <div className="max-w-4xl mx-auto space-y-4">
      <div className="space-y-2">
        <h1 className="text-3xl font-bold">Edit Event</h1>
        <p className="text-muted-foreground">
          Update your event details below.
        </p>
      </div>

      <Card className="p-6">
        <EventForm event={event} isEditing />
      </Card>
    </div>
  );
}

================
File: src/app/(dashboard)/events/[eventId]/loading.tsx
================
import { Skeleton } from "@/components/ui/skeleton";

export default function EventLoading() {
  return (
    <div className="space-y-6">
      <div className="space-y-2">
        <Skeleton className="h-8 w-1/3" />
        <Skeleton className="h-4 w-2/3" />
      </div>
      <div className="grid gap-6 md:grid-cols-2">
        <Skeleton className="h-[300px]" />
        <Skeleton className="h-[300px]" />
      </div>
    </div>
  );
}

================
File: src/app/(dashboard)/events/[eventId]/page.tsx
================
import { notFound } from "next/navigation";
import { format } from "date-fns";
import { 
  Calendar, 
  Clock, 
  MapPin, 
  Users, 
  Share2, 
  Download, 
  Mail, 
  MessageCircle,
  Settings,
  AlertCircle
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { ErrorBoundary } from "react-error-boundary";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { GuestList } from "@/components/events/guest-list";
import { EventChat } from "@/components/events/event-chat";
import { ShareEvent } from "@/components/events/share-event";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event as EventModel } from "@/lib/db/models/event";
import { serializeEvent } from "@/lib/utils";
import AdUnit from "@/components/ads/AdUnit";

function ErrorFallback({ error }: { error: Error }) {
  return (
    <div className="flex flex-col items-center justify-center h-[60vh] space-y-4">
      <p className="text-muted-foreground">Something went wrong</p>
      <pre className="text-sm text-red-500">{error.message}</pre>
    </div>
  );
}

async function getEvent(eventId: string) {
  try {
    await dbConnect();
    const event = await EventModel.findById(eventId).lean();
    if (!event) return null;
    return serializeEvent(event);
  } catch (error) {
    console.error("Error fetching event:", error);
    return null;
  }
}

export default async function EventPage({
  params,
}: {
  params: { eventId: string };
}) {
  const { userId } = await auth();
  const event = await getEvent(params.eventId);

  if (!event) {
    notFound();
  }

  const isOrganizer = userId === event.organizerId;
  const isCoHost = event.coHosts.includes(userId!);
  const canManageEvent = isOrganizer || isCoHost;

  return (
    <div className="space-y-6">
      {/* Header Section */}
      <div className="flex items-center justify-between">
        <div className="space-y-1">
          <div className="flex items-center space-x-2">
            <h1 className="text-3xl font-bold">{event.title}</h1>
            <Badge variant={event.status === "published" ? "default" : "secondary"}>
              {event.status}
            </Badge>
          </div>
          <p className="text-muted-foreground max-w-2xl">{event.description}</p>
        </div>
        
        {canManageEvent && (
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" size="icon">
                <Settings className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuLabel>Event Actions</DropdownMenuLabel>
              <DropdownMenuSeparator />
              <DropdownMenuItem>
                <Settings className="mr-2 h-4 w-4" /> Edit Event
              </DropdownMenuItem>
              <DropdownMenuItem>
                <Mail className="mr-2 h-4 w-4" /> Send Reminders
              </DropdownMenuItem>
              <DropdownMenuItem className="text-destructive">
                <AlertCircle className="mr-2 h-4 w-4" /> Cancel Event
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        )}
      </div>

      {/* Event Details */}
      <div className="grid gap-6 lg:grid-cols-3">
        <Card className="p-6 space-y-4 lg:col-span-2">
          <div className="flex items-center justify-between">
            <h2 className="text-xl font-semibold">Event Details</h2>
            <div className="flex space-x-2">
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="outline" size="icon">
                      <Share2 className="h-4 w-4" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>Share Event</TooltipContent>
                </Tooltip>
              </TooltipProvider>

              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="outline" size="icon">
                      <Download className="h-4 w-4" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>Download iCal</TooltipContent>
                </Tooltip>
              </TooltipProvider>
            </div>
          </div>
          
          <Separator />
          
          <div className="grid gap-6 lg:grid-cols-3">
            <div className="space-y-4">
              <div className="flex items-center space-x-2">
                <Calendar className="h-5 w-5 text-muted-foreground" />
                <div className="space-y-1">
                  <p className="font-medium">Date</p>
                  <p className="text-sm text-muted-foreground">
                    {format(new Date(event.startDate), "PPP")}
                  </p>
                </div>
              </div>
              
              <div className="flex items-center space-x-2">
                <Clock className="h-5 w-5 text-muted-foreground" />
                <div className="space-y-1">
                  <p className="font-medium">Time</p>
                  <p className="text-sm text-muted-foreground">
                    {format(new Date(event.startDate), "p")} - {format(new Date(event.endDate), "p")}
                  </p>
                </div>
              </div>
            </div>

            <div className="space-y-4">
              <div className="flex items-center space-x-2">
                <MapPin className="h-5 w-5 text-muted-foreground" />
                <div className="space-y-1">
                  <p className="font-medium">Location</p>
                  <p className="text-sm text-muted-foreground">
                    {event.location.venue}<br />
                    {event.location.address}
                  </p>
                </div>
              </div>
              
              <div className="flex items-center space-x-2">
                <Users className="h-5 w-5 text-muted-foreground" />
                <div className="space-y-1">
                  <p className="font-medium">Capacity</p>
                  <p className="text-sm text-muted-foreground">
                    {event.attendees?.confirmed || 0} confirmed / {event.capacity} maximum
                  </p>
                </div>
              </div>
            </div>
          </div>
        </Card>

        {/* Guest List */}
        <Card className="p-6 h-full">
          <h2 className="text-xl font-semibold mb-4">Guest List</h2>
          <Separator className="mb-4" />
          <GuestList eventId={event.id} />
        </Card>
      </div>

      {/* Chat Section */}
      <Card className="p-6">
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-xl font-semibold">Event Discussion</h2>
          <Button variant="outline" size="sm">
            <MessageCircle className="h-4 w-4 mr-2" />
            Chat Settings
          </Button>
        </div>
        <Separator className="mb-4" />
        <EventChat eventId={event.id} />
        <AdUnit 
              slot="30002"
              format="vertical"
              style={{ 
                position: "sticky",
                top: "2rem",
                minHeight: "100px",
                width: "400px",
                margin: "0 auto",
                display: "flex"
              }}
        />
      </Card>

      {/* Share Dialog */}
      <Dialog>
        <DialogTrigger asChild>
          <Button variant="outline" className="fixed bottom-4 right-4">
            <Share2 className="h-4 w-4 mr-2" />
            Share Event
          </Button>
        </DialogTrigger>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Share Event</DialogTitle>
            <DialogDescription>
              Share this event with your network
            </DialogDescription>
          </DialogHeader>
          <ShareEvent event={event} />
        </DialogContent>
      </Dialog>
    </div>
  );
}

================
File: src/app/(dashboard)/events/new/page.tsx
================
// src/app/(dashboard)/events/new/page.tsx
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { Card } from "@/components/ui/card";
import { EventForm } from "@/components/events/event-form";

export default async function NewEventPage() {
  const { userId } = await auth();
  if (!userId) {
    redirect("/sign-in");
  }

  return (
    <div className="max-w-4xl mx-auto space-y-4">
      <div className="space-y-2">
        <h1 className="text-3xl font-bold">Create New Event</h1>
        <p className="text-muted-foreground">
          Fill in the details below to create your event.
        </p>
      </div>

      <Card className="p-6">
        <EventForm />
      </Card>
    </div>
  );
}

================
File: src/app/(dashboard)/events/loading.tsx
================
import { Skeleton } from "@/components/ui/skeleton";

export default function EventsLoading() {
  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <Skeleton className="h-8 w-32" />
        <Skeleton className="h-10 w-28" />
      </div>
      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        {Array.from({ length: 6 }).map((_, i) => (
          <Skeleton key={i} className="h-[200px] rounded-lg" />
        ))}
      </div>
    </div>
  );
}

================
File: src/app/(dashboard)/events/page.tsx
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import Link from "next/link";
import { Plus } from "lucide-react";
import { Button } from "@/components/ui/button";
import { EventCard } from "@/components/events/event-card";
import { FeatureGate } from "@/components/subscription/feature-gate";
import dbConnect from "@/lib/db/connection";
import { Event as EventModel } from "@/lib/db/models/event";
import AdUnit from "@/components/ads/AdUnit";
import { FEATURES } from "@/types/subscription";

// Define the Event interface
interface Event {
  id: string;
  title: string;
  description: string;
  startDate: Date;
  endDate: Date;
  location: {
    venue: string;
    address: string;
    coordinates?: {
      lat: number;
      lng: number;
    };
  };
  capacity: number;
  status: "draft" | "published" | "cancelled";
  visibility: "public" | "private";
  organizerId: string;
  coHosts: string[];
  createdAt: Date;
  updatedAt: Date;
}

// Define the MongoDB document interface
interface EventDocument {
  _id: any;
  title: string;
  description: string;
  startDate: Date;
  endDate: Date;
  location: {
    venue: string;
    address: string;
    coordinates?: {
      lat: number;
      lng: number;
    };
  };
  capacity: number;
  status: "draft" | "published" | "cancelled";
  visibility: "public" | "private";
  organizerId: string;
  coHosts: string[];
  createdAt: Date;
  updatedAt: Date;
}

async function getEvents(userId: string): Promise<Event[]> {
  try {
    await dbConnect();
    const events = await EventModel.find({ organizerId: userId })
      .sort({ createdAt: -1 })
      .lean() as EventDocument[];

    return events.map(event => ({
      id: event._id.toString(),
      title: event.title,
      description: event.description,
      startDate: new Date(event.startDate),
      endDate: new Date(event.endDate),
      location: event.location,
      capacity: event.capacity,
      status: event.status,
      visibility: event.visibility,
      organizerId: event.organizerId,
      coHosts: event.coHosts,
      createdAt: new Date(event.createdAt),
      updatedAt: new Date(event.updatedAt)
    }));
  } catch (error) {
    console.error("Error fetching events:", error);
    return [];
  }
}

export default async function EventsPage() {
  const { userId } = await auth();
  if (!userId) redirect("/sign-in");

  const events = await getEvents(userId);

  return (
    <div className="space-y-6">      
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold">Events</h1>
        <FeatureGate 
          feature={FEATURES.RECURRING_EVENTS}
          fallback={
            <Button asChild>
              <Link href="/settings/subscription">
                <Plus className="mr-2 h-4 w-4" />
                Upgrade to Create Events
              </Link>
            </Button>
          }
        >
          <Button asChild>
            <Link href="/events/new">
              <Plus className="mr-2 h-4 w-4" />
              Create Event
            </Link>
          </Button>
        </FeatureGate>
      </div>     

      {events.length === 0 ? (
        <div className="flex flex-col items-center justify-center h-[60vh] space-y-4">
          <p className="text-muted-foreground">No events found</p>
          <FeatureGate 
            feature={FEATURES.RECURRING_EVENTS}
            fallback={
              <Button asChild>
                <Link href="/settings/subscription">Upgrade to Create Events</Link>
              </Button>
            }
          >
            <Button asChild>
              <Link href="/events/new">Create your first event</Link>
            </Button>
          </FeatureGate>
        </div>
      ) : (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-2">
          {events.map((event) => (
            <EventCard key={event.id} event={event} />
          ))}          
        </div>
      )}
      
      <div className="xl:block item-center justify-items-center justify-center shrink-0">
        <AdUnit 
          slot="30002"
          format="vertical"
          style={{ 
            position: "sticky",
            top: "2rem",
            minHeight: "100px",
            width: "400px",
            margin: "0 auto",
            display: "flex"
          }}
        />
      </div>      
    </div>
  );
}

================
File: src/app/(dashboard)/settings/subscription/page.tsx
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";
import { SubscriptionContent } from "@/components/subscription/subscription-content";
import { getCurrentSubscription } from "@/lib/subscription/subscription-service";

export default async function SubscriptionPage() {
  const { userId } = await auth();
  if (!userId) redirect("/sign-in");

  const subscription = await getCurrentSubscription(userId);

  return <SubscriptionContent currentPlan={subscription?.plan} />;
}

================
File: src/app/(dashboard)/layout.tsx
================
import { Navbar } from "@/components/layout/navbar";
import { SubscriptionProvider } from "@/components/subscription/SubscriptionProvider";
import { initialProfile } from "@/lib/auth";

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  await initialProfile();

  return (
    <SubscriptionProvider>
      <div className="h-full">
        <Navbar />
        <main className="container mx-auto h-full py-6">{children}</main>
      </div>
    </SubscriptionProvider>
  );
}

================
File: src/app/api/activities/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { clerkClient } from "@clerk/clerk-sdk-node"; 
import dbConnect from "@/lib/db/connection";
import { Activity } from "@/lib/db/models/activity";

export async function GET(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    // Get query parameters
    const { searchParams } = new URL(req.url);
    const limit = parseInt(searchParams.get("limit") || "20");
    const before = searchParams.get("before");
    const eventId = searchParams.get("eventId");
    const type = searchParams.get("type");

    // Build query
    let query: any = {};
    if (before) {
      query.createdAt = { $lt: new Date(before) };
    }
    if (eventId) {
      query.eventId = eventId;
    }
    if (type) {
      query.type = type;
    }

    // Fetch activities
    const activities = await Activity
      .find(query)
      .sort({ createdAt: -1 })
      .limit(limit);

    // Fetch user details from Clerk
    const userIds = Array.from(new Set(activities.map(a => a.userId)));
    const userDetails = new Map<string, any>();

    // In a real app, you would batch fetch users from Clerk
    // This is a simplified version
    for (const id of userIds) {
      try {
        const user = await clerkClient.users.getUser(userId);
        userDetails.set(id, {
          name: `${user.firstName} ${user.lastName}`,
          email: user.emailAddresses[0]?.emailAddress,
          avatar: user.imageUrl,
        });
      } catch (error) {
        console.error(`Error fetching user ${id}:`, error);
      }
    }

    // Enrich activities with user details
    const enrichedActivities = activities.map(activity => ({
      ...activity.toObject(),
      id: activity._id.toString(),
      user: userDetails.get(activity.userId) || null,
    }));

    return NextResponse.json(enrichedActivities);
  } catch (error) {
    console.error("Error fetching activities:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/activities/route.ts
================
// src/app/api/events/[eventId]/activities/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Activity } from "@/lib/db/models/activity";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const { searchParams } = new URL(req.url);
    const limit = parseInt(searchParams.get("limit") || "20");
    const before = searchParams.get("before");

    let query: any = { eventId: params.eventId };
    if (before) {
      query.createdAt = { $lt: new Date(before) };
    }

    const activities = await Activity
      .find(query)
      .sort({ createdAt: -1 })
      .limit(limit)
      .populate('userId', 'name avatar');

    return NextResponse.json(activities);
  } catch (error) {
    console.error("Error fetching activities:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/chat/[messageId]/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Message } from "@/lib/db/models/message";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";

// GET a single message
export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string; messageId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    // Check if user has access to the event
    const guest = await Guest.findOne({
      eventId: params.eventId,
      userId,
      status: { $in: ["confirmed", "checked_in"] }
    });

    if (!guest) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const message = await Message.findById(params.messageId)
      .populate('senderId', 'name avatar')
      .lean();

    if (!message) {
      return new NextResponse("Message not found", { status: 404 });
    }

    return NextResponse.json(message);
  } catch (error) {
    console.error("Error fetching message:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

// PATCH update a message
export async function PATCH(
  req: NextRequest,
  { params }: { params: { eventId: string; messageId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    const message = await Message.findById(params.messageId);
    if (!message) {
      return new NextResponse("Message not found", { status: 404 });
    }

    // Check if user is the message sender
    if (message.senderId.toString() !== userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const data = await req.json();
    const updatedMessage = await Message.findByIdAndUpdate(
      params.messageId,
      {
        $set: {
          content: data.content,
          edited: true,
          updatedAt: new Date()
        }
      },
      { new: true }
    ).populate('senderId', 'name avatar');

    return NextResponse.json(updatedMessage);
  } catch (error) {
    console.error("Error updating message:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

// DELETE a message
export async function DELETE(
  req: NextRequest,
  { params }: { params: { eventId: string; messageId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    // Check if user has permission to delete the message
    const [message, event] = await Promise.all([
      Message.findById(params.messageId),
      Event.findById(params.eventId)
    ]);

    if (!message) {
      return new NextResponse("Message not found", { status: 404 });
    }

    // Allow deletion if user is:
    // 1. The message sender
    // 2. The event organizer
    // 3. A co-host of the event
    const isMessageSender = message.senderId.toString() === userId;
    const isOrganizer = event?.organizerId === userId;
    const isCoHost = event?.coHosts?.includes(userId);

    if (!isMessageSender && !isOrganizer && !isCoHost) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await Message.findByIdAndDelete(params.messageId);

    return new NextResponse(null, { status: 204 });
  } catch (error) {
    console.error("Error deleting message:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/chat/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Message } from "@/lib/db/models/message";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import { pusherServer } from "@/lib/pusher";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    await dbConnect();
    const { searchParams } = new URL(req.url);
    const before = searchParams.get("before");
    const limit = parseInt(searchParams.get("limit") || "50");

    let query: any = { eventId: params.eventId };
    if (before) {
      query.createdAt = { $lt: new Date(before) };
    }

    const messages = await Message.find(query)
      .sort({ createdAt: -1 })
      .limit(limit)
      .populate('senderId', 'name avatar');

    return NextResponse.json(messages);
  } catch (error) {
    console.error("Error fetching messages:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function POST(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const data = await req.json();

    // Check if user is part of the event
    const guest = await Guest.findOne({
      eventId: params.eventId,
      userId,
      status: { $in: ["confirmed", "checked_in"] }
    });

    if (!guest) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const message = await Message.create({
      ...data,
      eventId: params.eventId,
      senderId: userId
    });

    // Broadcast message via Pusher
    await pusherServer.trigger(
      `event-${params.eventId}`,
      "new-message",
      {
        ...message.toJSON(),
        sender: {
          id: userId,
          name: data.senderName,
          avatar: data.senderAvatar
        }
      }
    );

    return NextResponse.json(message);
  } catch (error) {
    console.error("Error sending message:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/check-in/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Guest } from "@/lib/db/models/guest";
import { createActivity } from "@/lib/activity/notifications";

export async function POST(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const { guestId } = await req.json();

    const guest = await Guest.findOne({
      _id: guestId,
      eventId: params.eventId
    });

    if (!guest) {
      return new NextResponse("Guest not found", { status: 404 });
    }

    if (guest.checkedIn) {
      return new NextResponse("Guest already checked in", { status: 400 });
    }

  

    guest.checkedIn = true;
    guest.checkedInAt = new Date();
    await guest.save();

    // Create activity log
    await createActivity({
      type: "guest.checked_in",
      userId,
      eventId: params.eventId,
      metadata: {
        guestId: guest._id,
        guestName: guest.name
      }
    });

    return NextResponse.json(guest);
  } catch (error) {
    console.error("Error checking in guest:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/export/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import { createObjectCsvStringifier } from "csv-writer";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const event = await Event.findById(params.eventId);
    
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const guests = await Guest.find({ eventId: params.eventId });

    const csvStringifier = createObjectCsvStringifier({
      header: [
        { id: 'name', title: 'Name' },
        { id: 'email', title: 'Email' },
        { id: 'status', title: 'Status' },
        { id: 'checkedIn', title: 'Checked In' },
        { id: 'checkedInAt', title: 'Check-in Time' },
        { id: 'dietaryPreferences', title: 'Dietary Preferences' }
      ]
    });

    const records = guests.map(guest => ({
      name: guest.name,
      email: guest.email,
      status: guest.status,
      checkedIn: guest.checkedIn ? 'Yes' : 'No',
      checkedInAt: guest.checkedInAt ? new Date(guest.checkedInAt).toLocaleString() : '',
      dietaryPreferences: guest.dietaryPreferences?.join(', ') || ''
    }));

    const csv = csvStringifier.getHeaderString() + csvStringifier.stringifyRecords(records);

    return new NextResponse(csv, {
      headers: {
        'Content-Type': 'text/csv',
        'Content-Disposition': `attachment; filename="event-${event.title}-guests.csv"`
      }
    });
  } catch (error) {
    console.error("Error exporting event data:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/guests/[guestId]/route.ts
================
// src/app/api/events/[eventId]/guests/[guestId]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";  // Add this import
import { Guest } from "@/lib/db/models/guest";
import { ActivityTypes, createActivity } from "@/lib/activity/notifications";

// Type for the update request body
interface UpdateGuestRequest {
  status?: "confirmed" | "declined" | "waitlist" | "invited";
  role?: "attendee" | "coHost" | "moderator";
  checkedIn?: boolean;
  dietaryPreferences?: string[];
  notes?: string;
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: { eventId: string; guestId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const data = await req.json() as UpdateGuestRequest;

    // Validate the update data
    const allowedFields = [
      "status",
      "role",
      "checkedIn",
      "dietaryPreferences",
      "notes"
    ];
    const updateData = Object.fromEntries(
      Object.entries(data).filter(([key]) => allowedFields.includes(key))
    );

    // Find guest
    const guest = await Guest.findById(params.guestId);
    if (!guest) {
      return new NextResponse("Guest not found", { status: 404 });
    }

    // Find event
    const event = await Event.findById(params.eventId);
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Check permissions
    const canUpdate = 
      event.organizerId === userId || 
      event.coHosts.includes(userId) || 
      guest.userId === userId;

    if (!canUpdate) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Update guest with validation
    const updatedGuest = await Guest.findByIdAndUpdate(
      params.guestId,
      { 
        ...updateData,
        ...(updateData.checkedIn && { checkedInAt: new Date() })
      },
      { 
        new: true,
        runValidators: true 
      }
    );

    // Create activity log
    await createActivity({
      type: ActivityTypes.GUEST_UPDATED,
      userId,
      eventId: params.eventId,
      metadata: {
        guestId: params.guestId,
        updates: Object.keys(updateData).join(", ")
      }
    });

    return NextResponse.json(updatedGuest);
  } catch (error) {
    console.error("Error updating guest:", error);
    if (error instanceof Error) {
      return new NextResponse(error.message, { status: 400 });
    }
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: { eventId: string; guestId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    // Find event and check permissions
    const event = await Event.findById(params.eventId);
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Only organizers and co-hosts can remove guests
    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Find and delete guest
    const guest = await Guest.findById(params.guestId);
    if (!guest) {
      return new NextResponse("Guest not found", { status: 404 });
    }

    await Guest.findByIdAndDelete(params.guestId);

    // Create activity log
    await createActivity({
      type: ActivityTypes.GUEST_REMOVED,
      userId,
      eventId: params.eventId,
      metadata: { 
        guestId: params.guestId,
        guestEmail: guest.email // Include email for reference
      }
    });

    // Return success with no content
    return new NextResponse(null, { status: 204 });
  } catch (error) {
    console.error("Error removing guest:", error);
    if (error instanceof Error) {
      return new NextResponse(error.message, { status: 400 });
    }
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/guests/route.ts
================
// src/app/api/events/[eventId]/guests/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import { sendEventInvitation } from "@/lib/email/notifications";
import { createActivity } from "@/lib/activity/notifications";
import { formatDateTime } from "@/lib/email/notifications";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    await dbConnect();
    const { searchParams } = new URL(req.url);
    const status = searchParams.get("status");
    const search = searchParams.get("search");

    let query: any = { eventId: params.eventId };
    if (status) query.status = status;
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: "i" } },
        { email: { $regex: search, $options: "i" } }
      ];
    }

    const guests = await Guest.find(query).sort({ createdAt: -1 });
    return NextResponse.json(guests);
  } catch (error) {
    console.error("Error fetching guests:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function POST(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const data = await req.json();
    const event = await Event.findById(params.eventId);

    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Check if user has permission to invite
    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Format event date and time
    const { formattedDate, formattedTime } = formatDateTime(new Date(event.startDate));

    // Handle batch invitations
    const emails = Array.isArray(data.email) ? data.email : [data.email];
    const results = await Promise.all(
      emails.map(async (email: string) => {
        // Check if guest already exists
        const existingGuest = await Guest.findOne({
          eventId: params.eventId,
          email
        });

        if (existingGuest) {
          return {
            email,
            status: "already_invited"
          };
        }

        // Create new guest
        const guest = await Guest.create({
          eventId: params.eventId,
          email,
          status: "invited",
          role: data.role || "attendee",
          invitedBy: userId
        });

        // Send invitation email with properly formatted params
        await sendEventInvitation({
          recipientEmail: email,
          eventTitle: event.title,
          eventDate: formattedDate,
          eventTime: formattedTime,
          location: `${event.location.venue}, ${event.location.address}`,
          eventUrl: `${process.env.NEXT_PUBLIC_APP_URL}/events/${event.id}`,
          personalMessage: data.message
        });

        // Create activity
        await createActivity({
          type: "guest.invited",
          userId,
          eventId: params.eventId,
          metadata: { guestEmail: email }
        });

        return {
          email,
          status: "invited",
          guestId: guest._id
        };
      })
    );

    return NextResponse.json(results);
  } catch (error) {
    console.error("Error inviting guests:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/invite/route.ts
================
// src/app/api/events/[eventId]/invite/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import { sendEventInvitation } from "@/lib/email/notifications";

interface InviteRequestBody {
  emails: string[];
  message?: string;
}

export async function POST(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const { emails, message } = await req.json() as InviteRequestBody;

    // Validate request body
    if (!Array.isArray(emails) || emails.length === 0) {
      return new NextResponse("Invalid email addresses", { status: 400 });
    }

    // Connect to database
    await dbConnect();

    // Get event details
    const event = await Event.findById(params.eventId);
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Check if user is authorized to send invites
    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Create invitations and send emails
    const inviteResults = await Promise.allSettled(
      emails.map(async (email) => {
        try {
          // Check if guest already exists
          const existingGuest = await Guest.findOne({
            eventId: params.eventId,
            email: email.toLowerCase(),
          });

          if (existingGuest) {
            return {
              email,
              status: "already_invited",
            };
          }

          // Create new guest
          const guest = await Guest.create({
            eventId: params.eventId,
            email: email.toLowerCase(),
            status: "invited",
            role: "attendee",
            invitedBy: userId,
            invitedAt: new Date(),
          });

          // Format date and time for email
          const startDate = new Date(event.startDate);
          const formattedDate = startDate.toLocaleDateString('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
          });
          const formattedTime = startDate.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true,
          });

          // Send invitation email
          await sendEventInvitation({
            recipientEmail: email,
            eventTitle: event.title,
            eventDate: formattedDate,
            eventTime: formattedTime,
            location: `${event.location.venue}, ${event.location.address}`,
            eventUrl: `${process.env.NEXT_PUBLIC_APP_URL}/events/${event.id}`,
            personalMessage: message,
          });

          return {
            email,
            status: "invited",
            guestId: guest._id,
          };
        } catch (error) {
          console.error(`Error inviting ${email}:`, error);
          return {
            email,
            status: "failed",
            error: error instanceof Error ? error.message : "Unknown error",
          };
        }
      })
    );

    // Process results
    const results = inviteResults.map((result) => {
      if (result.status === "fulfilled") {
        return result.value;
      } else {
        return {
          email: "unknown",
          status: "failed",
          error: result.reason?.message || "Failed to process invitation",
        };
      }
    });

    // Check if any invitations were successful
    const successfulInvites = results.filter(
      (result) => result.status === "invited"
    );

    if (successfulInvites.length === 0) {
      return new NextResponse(
        JSON.stringify({
          message: "No invitations were sent successfully",
          results,
        }),
        { status: 400 }
      );
    }

    return new NextResponse(
      JSON.stringify({
        message: `Successfully sent ${successfulInvites.length} invitation(s)`,
        results,
      }),
      { status: 200 }
    );

  } catch (error) {
    console.error("Error sending invitations:", error);
    return new NextResponse(
      JSON.stringify({
        error: "Failed to send invitations",
        details: error instanceof Error ? error.message : "Unknown error",
      }),
      { status: 500 }
    );
  }
}

// a GET route to check invitation status
export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    const event = await Event.findById(params.eventId);
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Check authorization
    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Get all invitations for this event
    const guests = await Guest.find({ eventId: params.eventId })
      .select('email status invitedAt role checkedIn')
      .sort('-invitedAt');

    return NextResponse.json(guests);
  } catch (error) {
    console.error("Error fetching invitations:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/stats/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();

    const event = await Event.findById(params.eventId);
    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    const [
      totalGuests,
      confirmedGuests,
      checkedInGuests,
      waitlistedGuests
    ] = await Promise.all([
      Guest.countDocuments({ eventId: params.eventId }),
      Guest.countDocuments({ eventId: params.eventId, status: "confirmed" }),
      Guest.countDocuments({ eventId: params.eventId, checkedIn: true }),
      Guest.countDocuments({ eventId: params.eventId, status: "waitlist" })
    ]);

    return NextResponse.json({
      total: totalGuests,
      confirmed: confirmedGuests,
      checkedIn: checkedInGuests,
      waitlisted: waitlistedGuests,
      capacity: event.capacity,
      fillRate: (confirmedGuests / event.capacity) * 100,
      checkInRate: (checkedInGuests / confirmedGuests) * 100
    });
  } catch (error) {
    console.error("Error fetching event stats:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/waitlist/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Waitlist } from "@/lib/db/models/waitlist";
import { Guest } from "@/lib/db/models/guest";
import { ActivityTypes, createActivity } from "@/lib/activity/notifications";

export async function POST(
    req: NextRequest,
    { params }: { params: { eventId: string } }
  ) {
    try {
      const { userId } = await auth();
      if (!userId) {
        return new NextResponse("Unauthorized", { status: 401 });
      }
  
      await dbConnect();
      const event = await Event.findById(params.eventId);
  
      if (!event) {
        return new NextResponse("Event not found", { status: 404 });
      }
  
      // Check if waitlist is enabled
      if (!event.waitlist.enabled) {
        return new NextResponse("Waitlist not enabled for this event", { 
          status: 400 
        });
      }
  
      // Check if user is already registered or on waitlist
      const [existingGuest, existingWaitlist] = await Promise.all([
        Guest.findOne({ eventId: params.eventId, userId }),
        Waitlist.findOne({ eventId: params.eventId, userId })
      ]);
  
      if (existingGuest) {
        return new NextResponse("Already registered for event", { 
          status: 400 
        });
      }
  
      if (existingWaitlist) {
        return new NextResponse("Already on waitlist", { status: 400 });
      }
  
      // Get current waitlist position
      const lastPosition = await Waitlist.findOne({ 
        eventId: params.eventId 
      })
      .sort({ position: -1 })
      .select('position');
  
      const newPosition = lastPosition ? lastPosition.position + 1 : 1;
  
      // Check if waitlist is full
      if (event.waitlist.maxSize && newPosition > event.waitlist.maxSize) {
        return new NextResponse("Waitlist is full", { status: 400 });
      }
  
      // Add to waitlist
      const waitlistEntry = await Waitlist.create({
        eventId: params.eventId,
        userId,
        position: newPosition
      });
  
      // Create activity log with correct activity type
      await createActivity({
        type: ActivityTypes.GUEST_WAITLISTED,
        userId,
        eventId: params.eventId,
        metadata: { position: newPosition }
      });
  
      return NextResponse.json(waitlistEntry);
    } catch (error) {
      console.error("Error joining waitlist:", error);
      return new NextResponse("Internal Error", { status: 500 });
    }
}

// Get waitlist status
export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const waitlistEntry = await Waitlist.findOne({
      eventId: params.eventId,
      userId
    });

    return NextResponse.json(waitlistEntry || null);
  } catch (error) {
    console.error("Error getting waitlist status:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/[eventId]/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { auth } from "@clerk/nextjs/server";
import mongoose from "mongoose";

export async function GET(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    await dbConnect();

    // Validate ObjectId
    if (!mongoose.Types.ObjectId.isValid(params.eventId)) {
      return new NextResponse("Invalid event ID", { status: 400 });
    }

    const event = await Event.findById(params.eventId);

    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    // Convert Mongoose document to a plain JavaScript object
    const eventObject = event;

    // Create a serializable version of the event
    const serializedEvent = {
      id: eventObject._id.toString(),
      title: eventObject.title,
      description: eventObject.description,
      startDate: eventObject.startDate.toISOString(),
      endDate: eventObject.endDate.toISOString(),
      location: {
        venue: eventObject.location?.venue || '',
        address: eventObject.location?.address || '',
        coordinates: eventObject.location?.coordinates || null,
      },
      capacity: eventObject.capacity,
      status: eventObject.status,
      visibility: eventObject.visibility,
      organizerId: eventObject.organizerId,
      coHosts: eventObject.coHosts || [],
      recurring: eventObject.recurring || null,
      createdAt: eventObject.createdAt.toISOString(),
      updatedAt: eventObject.updatedAt.toISOString(),
      attendees: {
        confirmed: 0, // You'll need to fetch these counts separately
        waitlist: 0,
      },
    };

    return NextResponse.json(serializedEvent);
  } catch (error) {
    console.error("Error fetching event:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function PATCH(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const data = await req.json();
    const event = await Event.findById(params.eventId);

    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    if (event.organizerId !== userId && !event.coHosts.includes(userId)) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const updatedEvent = await Event.findByIdAndUpdate(
      params.eventId,
      { ...data },
      { new: true }
    );

    return NextResponse.json(updatedEvent);
  } catch (error) {
    console.error("Error updating event:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

export async function DELETE(
  req: NextRequest,
  { params }: { params: { eventId: string } }
) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const event = await Event.findById(params.eventId);

    if (!event) {
      return new NextResponse("Event not found", { status: 404 });
    }

    if (event.organizerId !== userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await Event.findByIdAndDelete(params.eventId);
    return new NextResponse(null, { status: 204 });
  } catch (error) {
    console.error("Error deleting event:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/recurring/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { addDays, addWeeks, addMonths, setDate } from "date-fns";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const data = await req.json();

    // Create base event
    const baseEvent = await Event.create({
      ...data,
      organizerId: userId
    });

    // Generate recurring instances if recurring is enabled
    if (data.recurring && data.recurring.pattern) {
      const instances = generateRecurringInstances(baseEvent);
      await Event.insertMany(instances);
    }

    return NextResponse.json(baseEvent);
  } catch (error) {
    console.error("Error creating recurring event:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

function generateRecurringInstances(baseEvent: any) {
  const instances = [];
  const { pattern, interval, endDate, daysOfWeek, dayOfMonth } = baseEvent.recurring;
  let currentDate = new Date(baseEvent.startDate);
  const duration = baseEvent.endDate.getTime() - baseEvent.startDate.getTime();

  while (currentDate <= new Date(endDate)) {
    // Skip the base event date
    if (currentDate.getTime() === baseEvent.startDate.getTime()) {
      currentDate = getNextDate(currentDate, pattern, interval);
      continue;
    }

    // Skip if date is in exceptions
    if (baseEvent.recurring.exceptions?.some((d: Date) => 
      d.getTime() === currentDate.getTime()
    )) {
      currentDate = getNextDate(currentDate, pattern, interval);
      continue;
    }

    // For weekly pattern, check if day is included
    if (pattern === "weekly" && daysOfWeek) {
      const dayOfWeek = currentDate.getDay();
      if (!daysOfWeek.includes(dayOfWeek)) {
        currentDate = addDays(currentDate, 1);
        continue;
      }
    }

    // For monthly pattern, check if it's the right day
    if (pattern === "monthly" && dayOfMonth) {
      if (currentDate.getDate() !== dayOfMonth) {
        currentDate = setDate(currentDate, dayOfMonth);
        continue;
      }
    }

    const instanceEndDate = new Date(currentDate.getTime() + duration);

    instances.push({
      ...baseEvent.toObject(),
      _id: undefined,
      startDate: currentDate,
      endDate: instanceEndDate,
      recurring: {
        ...baseEvent.recurring,
        originalEventId: baseEvent._id
      }
    });

    currentDate = getNextDate(currentDate, pattern, interval);
  }

  return instances;
}

function getNextDate(date: Date, pattern: string, interval: number): Date {
  switch (pattern) {
    case "daily":
      return addDays(date, interval);
    case "weekly":
      return addWeeks(date, interval);
    case "monthly":
      return addMonths(date, interval);
    default:
      return date;
  }
}

================
File: src/app/api/events/stats/charts/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";
import { startOfMonth, subMonths, format, startOfWeek, endOfWeek, subWeeks } from "date-fns";

export async function GET(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    await dbConnect();
    const now = new Date();

    // Get last 6 months of attendance data
    const monthlyAttendance = await Promise.all(
      Array.from({ length: 6 }).map(async (_, index) => {
        const monthStart = startOfMonth(subMonths(now, 5 - index));
        const monthName = format(monthStart, 'MMM');

        const monthEvents = await Event.find({
          organizerId: userId,
          startDate: {
            $gte: monthStart,
            $lt: startOfMonth(subMonths(now, 4 - index))
          }
        });

        const eventIds = monthEvents.map(event => event._id);
        const totalCapacity = monthEvents.reduce((sum, event) => sum + event.capacity, 0);
        
        const attendees = await Guest.countDocuments({
          eventId: { $in: eventIds },
          status: "checked_in"
        });

        return {
          name: monthName,
          attendees,
          capacity: totalCapacity || 0
        };
      })
    );

    // Get last 4 weeks of registration data
    const weeklyRegistrations = await Promise.all(
      Array.from({ length: 4 }).map(async (_, index) => {
        const weekStart = startOfWeek(subWeeks(now, 3 - index));
        const weekEnd = endOfWeek(subWeeks(now, 3 - index));

        const registrations = await Guest.countDocuments({
          createdAt: { $gte: weekStart, $lt: weekEnd },
          eventId: {
            $in: await Event.find({ organizerId: userId }).distinct('_id')
          }
        });

        return {
          name: `Week ${index + 1}`,
          registrations
        };
      })
    );

    // Get event types distribution
    const events = await Event.find({ organizerId: userId });
    const eventTypes = events.reduce((acc: { [key: string]: number }, event) => {
      const type = event.type || 'Other';
      acc[type] = (acc[type] || 0) + 1;
      return acc;
    }, {});

    const eventTypeData = Object.entries(eventTypes).map(([name, value]) => ({
      name,
      value
    }));

    return NextResponse.json({
      attendanceData: monthlyAttendance,
      registrationData: weeklyRegistrations,
      eventTypeData
    });
  } catch (error) {
    console.error("Error fetching chart data:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/events/upcoming/route.ts
================
// src/app/api/events/upcoming/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { Guest } from "@/lib/db/models/guest";

export async function GET(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    await dbConnect();

    const now = new Date();
    const thirtyDaysFromNow = new Date();
    thirtyDaysFromNow.setDate(now.getDate() + 30);

    // Fetch upcoming events
    const events = await Event.find({
      organizerId: userId,
      startDate: { $gte: now, $lte: thirtyDaysFromNow },
      status: { $ne: "cancelled" }
    })
    .sort({ startDate: 1 })
    .limit(5)
    .lean();

    // Get attendees count for each event
    const eventsWithAttendees = await Promise.all(
      events.map(async (event) => {
        const confirmedCount = await Guest.countDocuments({
          eventId: event._id,
          status: "confirmed"
        });

        const status = event.startDate > now 
          ? "upcoming"
          : event.endDate < now 
          ? "ended" 
          : "ongoing";

        return {
          id: event._id,
          title: event.title,
          description: event.description,
          startDate: event.startDate,
          endDate: event.endDate,
          location: {
            venue: event.location?.venue || 'No venue specified',
            address: event.location?.address || 'No address specified'
          },
          attendees: {
            confirmed: confirmedCount,
            total: event.capacity
          },
          status,
          visibility: event.visibility
        };
      })
    );

    return NextResponse.json({
      events: eventsWithAttendees,
      success: true
    });
  } catch (error) {
    console.error("Error fetching upcoming events:", error);
    return NextResponse.json(
      {
        error: "Failed to fetch upcoming events",
        success: false,
        details: process.env.NODE_ENV === 'development' ? error : undefined
      },
      { status: 500 }
    );
  }
}

================
File: src/app/api/events/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { auth } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";
import { handleApiError, ApiError } from '@/lib/api/error-handler';
import { analyzeQueryPerformance } from '@/lib/db/utils/performance';
import { trackEventCreation } from "@/lib/subscription/usage-tracking";
import { checkFeatureAccess } from "@/lib/subscription/feature-gates";
import { FEATURES, SUBSCRIPTION_PLANS, SubscriptionTier } from "@/types/subscription";
import { getCurrentSubscription } from "@/lib/subscription/subscription-service";

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      throw new ApiError('Unauthorized', 401, 'UNAUTHORIZED');
    }

    // Get current subscription first
    const subscription = await getCurrentSubscription(userId);
    if (!subscription) {
      return new NextResponse(
        "Subscription not found", 
        { status: 403 }
      );
    }

    const plan = SUBSCRIPTION_PLANS[subscription.planId as SubscriptionTier];
    
    // Check if user has permission to create events
    if (!plan.limits.features.includes(FEATURES.RECURRING_EVENTS)) {
      return new NextResponse(
        "Please upgrade your plan to create events.", 
        { status: 403 }
      );
    }

    // Check event creation limits
    try {
      await trackEventCreation(userId);
    } catch (error) {
      if (error instanceof Error && error.message === 'Monthly event limit reached') {
        return new NextResponse(
          `Event limit reached (${plan.limits.eventsPerMonth} per month). Please upgrade your plan.`, 
          { status: 403 }
        );
      }
      throw error;
    }

    await dbConnect();

    const data = await req.json();

    // Validate the event data based on subscription limits
    if (data.capacity > plan.limits.guestsPerEvent) {
      return new NextResponse(
        `Guest limit exceeded. Your plan allows up to ${plan.limits.guestsPerEvent} guests per event.`,
        { status: 403 }
      );
    }

    // Create the event
    const event = await Event.create({
      ...data,
      organizerId: userId,
      status: "draft",
      location: {
        venue: data.venue,
        address: data.address
      }
    });   

    // Convert to response format
    const responseEvent = {
      id: event._id.toString(),
      title: event.title,
      description: event.description,
      startDate: event.startDate.toISOString(),
      endDate: event.endDate.toISOString(),
      location: {
        venue: event.location?.venue || '',
        address: event.location?.address || '',
      },
      capacity: event.capacity,
      status: event.status,
      visibility: event.visibility,
      organizerId: event.organizerId,
      coHosts: event.coHosts || [],
    };

    // Revalidate paths
    revalidatePath("/events");
    revalidatePath("/dashboard");
    revalidatePath("/");

    return NextResponse.json(responseEvent);
  } catch (error) {
    console.error("Error creating event:", error);
    return handleApiError(error);    
  }
}

export async function GET(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      throw new ApiError('Unauthorized', 401, 'UNAUTHORIZED');
    }

    // Get current subscription
    const subscription = await getCurrentSubscription(userId);
    if (!subscription) {
      return new NextResponse(
        "Subscription not found", 
        { status: 403 }
      );
    }

    const plan = SUBSCRIPTION_PLANS[subscription.planId as SubscriptionTier];

    // Check if user has access to view events
    if (!plan.limits.features.includes(FEATURES.BASIC_ANALYTICS)) {
      return new NextResponse(
        "Please upgrade your plan to view events.", 
        { status: 403 }
      );
    }

    await dbConnect();

    // Parse query parameters
    const { searchParams } = new URL(req.url);
    const status = searchParams.get("status");
    const organizerId = searchParams.get("organizerId");

    // Build query
    let query: any = { organizerId: userId };
    if (status) query.status = status;
    if (organizerId) query.organizerId = organizerId;

    // Apply subscription limits
    const limit = plan.limits.eventsPerMonth === -1 ? 
      100 : // Default max for unlimited plans
      plan.limits.eventsPerMonth;

    const events = await Event.find(query)
      .sort({ startDate: -1 })
      .limit(limit);

    const serializedEvents = events.map(event => ({
      id: event._id.toString(),
      title: event.title,
      description: event.description,
      startDate: event.startDate.toISOString(),
      endDate: event.endDate.toISOString(),
      location: {
        venue: event.location?.venue || '',
        address: event.location?.address || '',
      },
      capacity: event.capacity,
      status: event.status,
      visibility: event.visibility,
      organizerId: event.organizerId,
      coHosts: event.coHosts || [],
    }));

    return NextResponse.json({
      events: serializedEvents,
      total: events.length,
      limit,
      hasMore: events.length === limit
    });

  } catch (error) {
    console.error("Error fetching events:", error);
    return handleApiError(error);
  }
}

================
File: src/app/api/sentry-example-api/route.ts
================
import { NextResponse } from "next/server";

export const dynamic = "force-dynamic";

// A faulty API route to test Sentry's error monitoring
export function GET() {
  throw new Error("Sentry Example API Route Error");
  return NextResponse.json({ data: "Testing Sentry Error..." });
}

================
File: src/app/api/subscriptions/checkout/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { auth, clerkClient } from "@clerk/nextjs/server";
import { stripe } from "@/lib/stripe";
import { absoluteUrl } from "@/lib/utils";
import { SUBSCRIPTION_PLANS } from "@/types/subscription";
import dbConnect from "@/lib/db/connection";
import { Subscription } from "@/lib/db/models/subscription";

const billingUrl = absoluteUrl("/settings/subscription");

interface SubscriptionPlan {
  id: string;
  name: string;
  price: number;
  stripePriceId?: string;
  limits: {
    eventsPerMonth: number;
    guestsPerEvent: number;
    features: string[];
  };
}

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const { planId } = await req.json();
    const plan = SUBSCRIPTION_PLANS[planId as keyof typeof SUBSCRIPTION_PLANS] as SubscriptionPlan;

    if (!plan) {
      return new NextResponse("Invalid plan selected", { status: 400 });
    }

    // Check if plan is free
    if (plan.id === 'free') {
      return new NextResponse("Cannot create checkout session for free plan", { status: 400 });
    }

    // Verify stripePriceId exists for paid plans
    if (!plan.stripePriceId) {
      return new NextResponse("Invalid plan configuration", { status: 400 });
    }

    // Get user from Clerk
    const user = await (await clerkClient()).users.getUser(userId);
    const email = user.emailAddresses[0].emailAddress;

    await dbConnect();

    // Check existing subscription
    const existingSubscription = await Subscription.findOne({ 
      userId,
      status: { $in: ['active', 'trialing'] }
    });

    if (existingSubscription?.stripeSubscriptionId) {
      return new NextResponse("Active subscription exists", { status: 400 });
    }

    // Get or create customer
    let customerId = existingSubscription?.stripeCustomerId;

    if (!customerId) {
      const customer = await stripe.customers.create({
        email,
        metadata: {
          userId,
          clerkId: userId,
          planId
        }
      });
      customerId = customer.id;

      // Create or update subscription record
      await Subscription.findOneAndUpdate(
        { userId },
        {
          userId,
          planId,
          plan: planId.toLowerCase(),
          stripeCustomerId: customerId,
          status: 'incomplete',
          features: plan.limits.features,
          limits: {
            maxEvents: plan.limits.eventsPerMonth,
            maxGuestsPerEvent: plan.limits.guestsPerEvent
          },
          usage: {
            eventsCreated: 0,
            totalGuests: 0,
            lastReset: new Date()
          }
        },
        { upsert: true }
      );
    }

    // Create checkout session
    const session = await stripe.checkout.sessions.create({
      customer: customerId,
      mode: "subscription",
      payment_method_types: ["card"],
      line_items: [
        {
          price: plan.stripePriceId,
          quantity: 1,
        },
      ],
      success_url: `${billingUrl}?success=true&session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${billingUrl}?canceled=true`,
      subscription_data: {
        metadata: {
          userId,
          planId
        },
        trial_period_days: 14 // Optional: Remove if you don't want to offer a trial
      },
      metadata: {
        userId,
        planId
      }
    });

    return NextResponse.json({ 
      sessionId: session.id,
      customerId 
    });
  } catch (error) {
    console.error("Error creating checkout session:", error);
    if (error instanceof Error) {
      return new NextResponse(error.message, { status: 500 });
    }
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/subscriptions/create-checkout/route.ts
================
// src/app/api/subscriptions/create-checkout/route.ts
import { NextResponse } from 'next/server';
import { auth, clerkClient } from '@clerk/nextjs/server';
import { stripe } from '@/lib/stripe';
import dbConnect from '@/lib/db/connection';
import { Subscription } from '@/lib/db/models/subscription';
import { absoluteUrl } from '@/lib/utils';
import { SUBSCRIPTION_PLANS, SubscriptionTier, SubscriptionStatus } from '@/types/subscription';
import { handleApiError, ApiError } from '@/lib/api/error-handler';

export async function POST(req: Request) {
  try {
    // 1. Get authenticated user
    const { userId } = await auth();
    if (!userId) {
      throw new ApiError('Unauthorized', 401, 'UNAUTHORIZED');
    }

    // 2. Get and validate request data
    const { planId, returnUrl } = await req.json();
    const plan = SUBSCRIPTION_PLANS[planId as SubscriptionTier];
    
    if (!plan?.stripePriceId) {
      throw new ApiError('Invalid plan selected', 400, 'INVALID_PLAN');
    }

    // 3. Get user details and validate email
    const user = await (await clerkClient()).users.getUser(userId);
    const email = user.emailAddresses[0].emailAddress;
    
    if (!email) {
      throw new ApiError('Email address required', 400, 'EMAIL_REQUIRED');
    }

    await dbConnect();

    // 4. Check existing subscription with more detailed status check
    const existingSubscription = await Subscription.findOne({ 
      userId,
      status: { 
        $in: [
          SubscriptionStatus.ACTIVE,
          SubscriptionStatus.TRIALING,
          SubscriptionStatus.PAST_DUE
        ] 
      }
    });

    if (existingSubscription?.stripeSubscriptionId) {
      // Handle subscription upgrade/downgrade if needed
      const currentPlan = SUBSCRIPTION_PLANS[existingSubscription.plan as SubscriptionTier];
      if (currentPlan.price > plan.price) {
        throw new ApiError(
          'Cannot downgrade subscription directly. Please cancel current subscription first.',
          400,
          'INVALID_DOWNGRADE'
        );
      }
    }

    // 5. Get or create Stripe customer with better metadata
    let customer;
    if (existingSubscription?.stripeCustomerId) {
      customer = await stripe.customers.retrieve(existingSubscription.stripeCustomerId);
      // Update customer metadata if needed
      await stripe.customers.update(customer.id, {
        metadata: {
          userId,
          clerkId: userId,
          planId,
          email
        }
      });
    } else {
      customer = await stripe.customers.create({
        email,
        metadata: {
          userId,
          clerkId: userId,
          planId,
          email
        }
      });
    }

    // 6. Create or update subscription record with enhanced tracking
    const subscriptionDoc = await Subscription.findOneAndUpdate(
      { userId },
      {
        userId,
        planId,
        plan: planId as SubscriptionTier,
        stripeCustomerId: customer.id,
        status: SubscriptionStatus.INCOMPLETE,
        features: plan.limits.features,
        limits: {
          maxEvents: plan.limits.eventsPerMonth,
          maxGuestsPerEvent: plan.limits.guestsPerEvent
        },
        usage: {
          eventsCreated: 0,
          totalGuests: 0,
          lastReset: new Date()
        },
        updatedAt: new Date()
      },
      { upsert: true, new: true }
    );

    // 7. Create checkout session with enhanced configuration
    const session = await stripe.checkout.sessions.create({
      customer: customer.id,
      line_items: [
        {
          price: plan.stripePriceId,
          quantity: 1,
        },
      ],
      mode: 'subscription',
      success_url: absoluteUrl(returnUrl || '/settings/subscription?success=true'),
      cancel_url: absoluteUrl('/settings/subscription?canceled=true'),
      allow_promotion_codes: true,
      billing_address_collection: 'auto',
      payment_method_types: ['card'],
      customer_update: {
        address: 'auto',
        name: 'auto'
      },
      subscription_data: {
        metadata: {
          userId,
          planId,
          subscriptionId: subscriptionDoc._id.toString(),
          features: JSON.stringify(plan.limits.features),
          maxEvents: plan.limits.eventsPerMonth,
          maxGuestsPerEvent: plan.limits.guestsPerEvent
        },
        trial_period_days: plan.trialDays || 14,
        description: `${plan.name} Plan - ${plan.description}`
      },
      metadata: {
        userId,
        planId,
        subscriptionId: subscriptionDoc._id.toString()
      }
    });

    // 8. Update subscription with session ID
    await Subscription.findByIdAndUpdate(subscriptionDoc._id, {
      checkoutSessionId: session.id
    });

    return NextResponse.json({ 
      url: session.url,
      sessionId: session.id,
      customerId: customer.id,
      subscriptionId: subscriptionDoc._id.toString()
    });
  } catch (error) {
    console.error('Error creating checkout session:', error);
    return handleApiError(error);
  }
}

================
File: src/app/api/subscriptions/portal/route.ts
================
// src/app/api/subscriptions/portal/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { stripe } from "@/lib/stripe";
import { absoluteUrl } from "@/lib/utils";
import dbConnect from "@/lib/db/connection";
import { Subscription } from "@/lib/db/models/subscription";
import { handleApiError, ApiError } from '@/lib/api/error-handler';
import { SUBSCRIPTION_PLANS, SubscriptionTier } from "@/types/subscription";

export async function POST(req: NextRequest) {
  try {
    const { userId } = await auth();
    if (!userId) {
      throw new ApiError('Unauthorized', 401, 'UNAUTHORIZED');
    }

    await dbConnect();
    
    // Find active subscription
    const subscription = await Subscription.findOne({ 
      userId,
      status: { $in: ['active', 'trialing', 'past_due'] }
    });

    if (!subscription?.stripeCustomerId) {
      throw new ApiError('No active subscription found', 404, 'SUBSCRIPTION_NOT_FOUND');
    }

    const plan = SUBSCRIPTION_PLANS[subscription.plan as SubscriptionTier];

    // Create portal configuration based on plan
    const portalConfiguration = {
      business_profile: {
        headline: `Manage your ${plan.name} subscription`,
      },
      features: {
        subscription_update: {
          enabled: true,
          products: [process.env.STRIPE_PRODUCT_ID!]
        },
        payment_method_update: {
          enabled: true
        },
        customer_update: {
          enabled: true,
          allowed_updates: ['email', 'address']
        },
        invoice_history: {
          enabled: true
        }
      }
    };

    // Create Stripe portal session
    const session = await stripe.billingPortal.sessions.create({
      customer: subscription.stripeCustomerId,
      return_url: absoluteUrl("/settings/subscription"),
      configuration: subscription.plan === 'BUSINESS' ? 
        process.env.STRIPE_BUSINESS_PORTAL_CONFIG :
        process.env.STRIPE_STANDARD_PORTAL_CONFIG,
      flow_data: {
        type: 'subscription_cancel',
        subscription_cancel: {
          subscription: subscription.stripeSubscriptionId!
        }
      }
    });

    return NextResponse.json({ 
      url: session.url,
      customerId: subscription.stripeCustomerId,
      planId: subscription.plan
    });
  } catch (error) {
    console.error("Error creating portal session:", error);
    return handleApiError(error);
  }
}

================
File: src/app/api/subscriptions/route.ts
================
import { NextResponse } from 'next/server';
import { auth } from '@clerk/nextjs/server';
import { createOrUpdateSubscription, getCurrentSubscription } from '@/lib/subscription/subscription-service';

export async function POST(req: Request) {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse('Unauthorized', { status: 401 });
    }

    const body = await req.json();
    
    // Validate the request body
    if (!body.plan) {
      return NextResponse.json(
        { error: 'Plan is required' },
        { status: 400 }
      );
    }

    const subscriptionData = {
      userId,
      plan: body.plan,
      planId: body.planId,
      stripePriceId: body.stripePriceId,
      currentPeriodEnd: body.currentPeriodEnd ? new Date(body.currentPeriodEnd) : undefined,
      status: body.status || 'active',
      stripeCustomerId: body.stripeCustomerId,
      stripeSubscriptionId: body.stripeSubscriptionId
    };

    const subscription = await createOrUpdateSubscription(userId, subscriptionData);

    return NextResponse.json(subscription);
  } catch (error) {
    console.error('Subscription error:', error);
    
    // Return a more detailed error response
    return NextResponse.json(
      { 
        error: 'Failed to update subscription',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

export async function GET() {
  try {
    const { userId } = await auth();
    if (!userId) {
      return new NextResponse('Unauthorized', { status: 401 });
    }

    const subscription = await getCurrentSubscription(userId);
    return NextResponse.json(subscription);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch subscription' },
      { status: 500 }
    );
  }
}

================
File: src/app/api/users/[userId]/route.ts
================
// src/app/api/users/[userId]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { clerkClient } from "@clerk/clerk-sdk-node"; 
import { auth } from "@clerk/nextjs/server";

export async function GET(
  req: NextRequest,
  { params }: { params: { userId: string } }
) {
  try {
    const { userId: currentUserId } = await auth();
    if (!currentUserId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const user = await clerkClient.users.getUser(params.userId);

    return NextResponse.json({
      id: user.id,
      name: `${user.firstName} ${user.lastName}`,
      imageUrl: user.imageUrl,
      emailAddress: user.emailAddresses[0]?.emailAddress
    });
  } catch (error) {
    console.error("Error fetching user:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}

================
File: src/app/api/webhooks/clerk/route.ts
================
import { Webhook } from 'svix';
import { headers } from 'next/headers';
import { WebhookEvent } from '@clerk/nextjs/server';
import { NextResponse } from 'next/server';
import dbConnect from '@/lib/db/connection';

export async function POST(req: Request) {
  const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;
  
  if (!WEBHOOK_SECRET) {
    throw new Error('Please add WEBHOOK_SECRET from Clerk Dashboard to .env file');
  }

  // Get the headers
  const headerPayload = headers();
  const svix_id = headerPayload.get("svix-id");
  const svix_timestamp = headerPayload.get("svix-timestamp");
  const svix_signature = headerPayload.get("svix-signature");

  // If there are no headers, error out
  if (!svix_id || !svix_timestamp || !svix_signature) {
    return new NextResponse('Error occured -- no svix headers', {
      status: 400
    });
  }

  // Get the body
  const payload = await req.json();
  const body = JSON.stringify(payload);

  // Create a new Svix instance with your secret
  const wh = new Webhook(WEBHOOK_SECRET);

  let evt: WebhookEvent;

  try {
    evt = wh.verify(body, {
      "svix-id": svix_id,
      "svix-timestamp": svix_timestamp,
      "svix-signature": svix_signature,
    }) as WebhookEvent;
  } catch (err) {
    console.error('Error verifying webhook:', err);
    return new NextResponse('Error occured', {
      status: 400
    });
  }

  // Handle the webhook
  const eventType = evt.type;
  
  try {
    await dbConnect();
    
    switch (eventType) {
      case 'user.created':
        // Handle user creation
        break;
      case 'user.updated':
        // Handle user update
        break;
      case 'user.deleted':
        // Handle user deletion
        break;
    }

    return NextResponse.json({
      success: true,
      message: `Webhook processed successfully`
    });
    
  } catch (error) {
    console.error('Error processing webhook:', error);
    return new NextResponse('Error processing webhook', { 
      status: 500 
    });
  }
}

================
File: src/app/api/webhooks/stripe/route.ts
================
// app/api/webhooks/stripe/route.ts
import { headers } from "next/headers";
import { NextResponse } from "next/server";
import dbConnect from "@/lib/db/connection";
import { Subscription } from "@/lib/db/models/subscription";
import { stripe } from "@/lib/stripe";
import Stripe from "stripe";

// Define the expected Stripe event types
type StripeSubscriptionEvent = Stripe.Event & {
  type: 'customer.subscription.created' | 'customer.subscription.updated' | 'customer.subscription.deleted';
  data: {
    object: Stripe.Subscription;
  };
};

// Type guard to check if the event is a subscription event
function isSubscriptionEvent(event: Stripe.Event): event is StripeSubscriptionEvent {
  return [
    'customer.subscription.created',
    'customer.subscription.updated',
    'customer.subscription.deleted'
  ].includes(event.type);
}

export async function POST(req: Request) {
  try {
    const body = await req.text();
    const signature = headers().get("stripe-signature");

    if (!signature || !process.env.STRIPE_WEBHOOK_SECRET) {
      return new NextResponse('Missing signature or webhook secret', { status: 400 });
    }

    // 1. Validate webhook signature
    const event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET
    );

    await dbConnect();

    // 2. Handle different webhook events
    if (isSubscriptionEvent(event)) {
      const subscription = event.data.object;

      switch (event.type) {
        case 'customer.subscription.created':
        case 'customer.subscription.updated': {
          await Subscription.findOneAndUpdate(
            { stripeSubscriptionId: subscription.id },
            {
              $set: {
                userId: subscription.metadata.userId,
                planId: subscription.metadata.planId,
                status: subscription.status,
                stripeCustomerId: subscription.customer as string,
                stripePriceId: subscription.items.data[0].price.id,
                currentPeriodEnd: new Date(subscription.current_period_end * 1000),
              }
            },
            { upsert: true }
          );
          break;
        }

        case 'customer.subscription.deleted': {
          await Subscription.findOneAndUpdate(
            { stripeSubscriptionId: subscription.id },
            {
              $set: {
                status: 'canceled',
                currentPeriodEnd: new Date(subscription.current_period_end * 1000),
                cancelAtPeriodEnd: true
              }
            }
          );
          break;
        }
      }
    }

    return new NextResponse(null, { status: 200 });
  } catch (error) {
    console.error('Error handling webhook:', error);
    if (error instanceof Stripe.errors.StripeError) {
      return new NextResponse(error.message, { status: 400 });
    }
    return new NextResponse('Webhook Error', { status: 400 });
  }
}

export const config = {
  api: { bodyParser: false },
};

================
File: src/app/api/mocks.ts
================
async function initMocks() {
    if (typeof window === 'undefined') {
      const { server } = await import('../../mocks/server');
      server.listen({ onUnhandledRequest: 'bypass' });
    } else {
      const { worker } = await import('../../mocks/browser');
      worker.start({ onUnhandledRequest: 'bypass' });
    }
}
  
export default initMocks;

================
File: src/app/sentry-example-page/page.tsx
================
"use client";

import Head from "next/head";
import * as Sentry from "@sentry/nextjs";

export default function Page() {
  return (
    <div>
      <Head>
        <title>Sentry Onboarding</title>
        <meta name="description" content="Test Sentry for your Next.js app!" />
      </Head>

      <main
        style={{
          minHeight: "100vh",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
        }}
      >
        <h1 style={{ fontSize: "4rem", margin: "14px 0" }}>
          <svg
            style={{
              height: "1em",
            }}
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 200 44"
          >
            <path
              fill="currentColor"
              d="M124.32,28.28,109.56,9.22h-3.68V34.77h3.73V15.19l15.18,19.58h3.26V9.22h-3.73ZM87.15,23.54h13.23V20.22H87.14V12.53h14.93V9.21H83.34V34.77h18.92V31.45H87.14ZM71.59,20.3h0C66.44,19.06,65,18.08,65,15.7c0-2.14,1.89-3.59,4.71-3.59a12.06,12.06,0,0,1,7.07,2.55l2-2.83a14.1,14.1,0,0,0-9-3c-5.06,0-8.59,3-8.59,7.27,0,4.6,3,6.19,8.46,7.52C74.51,24.74,76,25.78,76,28.11s-2,3.77-5.09,3.77a12.34,12.34,0,0,1-8.3-3.26l-2.25,2.69a15.94,15.94,0,0,0,10.42,3.85c5.48,0,9-2.95,9-7.51C79.75,23.79,77.47,21.72,71.59,20.3ZM195.7,9.22l-7.69,12-7.64-12h-4.46L186,24.67V34.78h3.84V24.55L200,9.22Zm-64.63,3.46h8.37v22.1h3.84V12.68h8.37V9.22H131.08ZM169.41,24.8c3.86-1.07,6-3.77,6-7.63,0-4.91-3.59-8-9.38-8H154.67V34.76h3.8V25.58h6.45l6.48,9.2h4.44l-7-9.82Zm-10.95-2.5V12.6h7.17c3.74,0,5.88,1.77,5.88,4.84s-2.29,4.86-5.84,4.86Z M29,2.26a4.67,4.67,0,0,0-8,0L14.42,13.53A32.21,32.21,0,0,1,32.17,40.19H27.55A27.68,27.68,0,0,0,12.09,17.47L6,28a15.92,15.92,0,0,1,9.23,12.17H4.62A.76.76,0,0,1,4,39.06l2.94-5a10.74,10.74,0,0,0-3.36-1.9l-2.91,5a4.54,4.54,0,0,0,1.69,6.24A4.66,4.66,0,0,0,4.62,44H19.15a19.4,19.4,0,0,0-8-17.31l2.31-4A23.87,23.87,0,0,1,23.76,44H36.07a35.88,35.88,0,0,0-16.41-31.8l4.67-8a.77.77,0,0,1,1.05-.27c.53.29,20.29,34.77,20.66,35.17a.76.76,0,0,1-.68,1.13H40.6q.09,1.91,0,3.81h4.78A4.59,4.59,0,0,0,50,39.43a4.49,4.49,0,0,0-.62-2.28Z"
            ></path>
          </svg>
        </h1>

        <p>Get started by sending us a sample error:</p>
        <button
          type="button"
          style={{
            padding: "12px",
            cursor: "pointer",
            backgroundColor: "#AD6CAA",
            borderRadius: "4px",
            border: "none",
            color: "white",
            fontSize: "14px",
            margin: "18px",
          }}
          onClick={async () => {
            await Sentry.startSpan(
              {
                name: "Example Frontend Span",
                op: "test",
              },
              async () => {
                const res = await fetch("/api/sentry-example-api");
                if (!res.ok) {
                  throw new Error("Sentry Example Frontend Error");
                }
              },
            );
          }}
        >
          Throw error!
        </button>

        <p>
          Next, look for the error on the{" "}
          <a href="https://shareflyt.sentry.io/issues/?project=4508246045556816">
            Issues Page
          </a>
          .
        </p>
        <p style={{ marginTop: "24px" }}>
          For more information, see{" "}
          <a href="https://docs.sentry.io/platforms/javascript/guides/nextjs/">
            https://docs.sentry.io/platforms/javascript/guides/nextjs/
          </a>
        </p>
      </main>
    </div>
  );
}

================
File: src/app/error.tsx
================
'use client';

import { useEffect } from 'react';
import { Button } from "@/components/ui/button";
import * as Sentry from "@sentry/nextjs";

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    Sentry.captureException(error);
  }, [error]);

  return (
    <div className="flex h-screen flex-col items-center justify-center space-y-4">
      <h1 className="text-4xl font-bold">Something went wrong!</h1>
      <p className="text-muted-foreground">We apologize for the inconvenience.</p>
      <div className="flex space-x-4">
        <Button onClick={() => reset()}>Try again</Button>
        <Button variant="outline" asChild>
          <a href="/">Go Home</a>
        </Button>
      </div>
    </div>
  );
}

================
File: src/app/global-error.tsx
================
// src/app/global-error.tsx
'use client';

import * as Sentry from "@sentry/nextjs";
import { useEffect } from "react";

export default function GlobalError({
  error,
}: {
  error: Error & { digest?: string };
}) {
  useEffect(() => {
    Sentry.captureException(error);
  }, [error]);

  return (
    <html>
      <body>
        <div className="flex min-h-screen items-center justify-center">
          <div className="text-center">
            <h1 className="text-2xl font-bold">Something went wrong!</h1>
            <button
              className="mt-4 rounded bg-primary px-4 py-2 text-white"
              onClick={() => window.location.reload()}
            >
              Try again
            </button>
          </div>
        </div>
      </body>
    </html>
  );
}

================
File: src/app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
 
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
 
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
 
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
 
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
 
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
 
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
 
    --radius: 0.5rem;
 
    --chart-1: 12 76% 61%;
 
    --chart-2: 173 58% 39%;
 
    --chart-3: 197 37% 24%;
 
    --chart-4: 43 74% 66%;
 
    --chart-5: 27 87% 67%;
  }
 
  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
 
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
 
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
 
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
 
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
 
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
 
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
 
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
 
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}
 
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: src/app/layout.tsx
================
import { ClerkProvider } from '@clerk/nextjs'
import { Inter } from 'next/font/google'
import type { Metadata } from 'next'
import { ThemeProvider } from '@/components/providers/theme-provider'
import { Toaster } from '@/components/ui/toaster'
import './globals.css'
import { ErrorBoundary } from 'react-error-boundary';
import { GlobalError } from '@/components/error-boundary/global-error';
import { AdSense } from "@/components/ads/AdSense";


const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: {
    default: 'Feest - Event Management Platform',
    template: '%s | Feest'
  },
  description: 'Professional event management platform for organizing and managing events',
  keywords: ['events', 'management', 'organization', 'planning'],
  authors: [{ name: 'user52' }],
  creator: 'Shareflyt',
  openGraph: {
    type: 'website',
    locale: 'en_US',
    url: 'https://your-domain.com',
    title: 'Feest - Event Management Platform',
    description: 'Professional event management platform for organizing and managing events',
    siteName: 'Feest'
  },
  twitter: {
    card: 'summary_large_image',
    title: 'Feest - Event Management Platform',
    description: 'Professional event management platform for organizing and managing events',
    creator: '@ch1pset4x'
  },
  robots: {
    index: true,
    follow: true
  }
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {  
  return (
    <ClerkProvider dynamic={true}>
      <html lang="en" suppressHydrationWarning>
        <head>
        <AdSense publisherId={process.env.NEXT_PUBLIC_GOOGLE_ADS_CLIENT_ID!} />
        </head>
        <body className={inter.className}>
          <ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
          >
            <ErrorBoundary 
              FallbackComponent={GlobalError}              
            >
              {children}
            </ErrorBoundary>
            <Toaster />
          </ThemeProvider>
        </body>
      </html>
    </ClerkProvider>
  )
}

================
File: src/app/not-found.tsx
================
import Link from "next/link";
import { Button } from "@/components/ui/button";

export default function NotFound() {
  return (
    <div className="flex h-screen flex-col items-center justify-center space-y-4">
      <h1 className="text-4xl font-bold">404</h1>
      <p className="text-muted-foreground">The page you're looking for doesn't exist.</p>
      <Button asChild>
        <Link href="/">Go Home</Link>
      </Button>
    </div>
  );
}

================
File: src/app/page.tsx
================
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { ArrowRight, Calendar, Users, BarChart3, Zap, CheckCircle, Clock } from "lucide-react";
import Link from "next/link";

export default function LandingPage() {
  return (
    <div className="flex min-h-screen flex-col">
      {/* Hero Section */}
      <div className="flex flex-col items-center justify-center space-y-8 px-4 py-24 text-center lg:py-32">
        <Badge className="mb-4" variant="secondary">
           Your events, managed perfectly
        </Badge>
        <h1 className="text-3xl font-bold tracking-tighter sm:text-5xl md:text-6xl lg:text-7xl">
          Event Management
          <span className="block bg-gradient-to-r from-primary to-primary/50 bg-clip-text text-transparent">
            Made Simple
          </span>
        </h1>
        <p className="mx-auto max-w-[700px] text-muted-foreground md:text-xl">
          Create, manage, and host remarkable events. From intimate gatherings to
          grand conferences, we've got you covered.
        </p>
        <div className="flex flex-col gap-4 min-[400px]:flex-row">
          <Button asChild size="lg" className="gap-2">
            <Link href="/sign-up">
              Get Started <ArrowRight className="h-4 w-4" />
            </Link>
          </Button>
          <Button asChild size="lg" variant="outline">
            <Link href="/sign-in">
              Sign In
            </Link>
          </Button>
        </div>
      </div>

      {/* Features Grid */}
      <div className="container mx-auto grid gap-8 px-4 py-16 md:grid-cols-2 lg:grid-cols-3">
        <div className="group relative overflow-hidden rounded-lg border bg-background p-6 shadow-md transition-all hover:-translate-y-1 hover:shadow-lg">
          <div className="absolute inset-0 bg-gradient-to-r from-primary/10 to-transparent opacity-0 transition-opacity group-hover:opacity-100" />
          <Calendar className="mb-4 h-8 w-8 text-primary" />
          <h3 className="mb-2 font-semibold">Smart Scheduling</h3>
          <p className="text-sm text-muted-foreground">
            Intelligent calendar management with conflict detection and timezone support.
          </p>
        </div>

        <div className="group relative overflow-hidden rounded-lg border bg-background p-6 shadow-md transition-all hover:-translate-y-1 hover:shadow-lg">
          <div className="absolute inset-0 bg-gradient-to-r from-primary/10 to-transparent opacity-0 transition-opacity group-hover:opacity-100" />
          <Users className="mb-4 h-8 w-8 text-primary" />
          <h3 className="mb-2 font-semibold">Attendee Management</h3>
          <p className="text-sm text-muted-foreground">
            Seamlessly manage guest lists, RSVPs, and check-ins with real-time updates.
          </p>
        </div>

        <div className="group relative overflow-hidden rounded-lg border bg-background p-6 shadow-md transition-all hover:-translate-y-1 hover:shadow-lg">
          <div className="absolute inset-0 bg-gradient-to-r from-primary/10 to-transparent opacity-0 transition-opacity group-hover:opacity-100" />
          <BarChart3 className="mb-4 h-8 w-8 text-primary" />
          <h3 className="mb-2 font-semibold">Insightful Analytics</h3>
          <p className="text-sm text-muted-foreground">
            Comprehensive analytics and reporting to track event performance.
          </p>
        </div>
      </div>

      {/* Stats Section
      <div className="border-t bg-muted/40">
        <div className="container mx-auto px-4 py-16">
          <div className="grid gap-8 md:grid-cols-3">
            <div className="text-center">
              <div className="text-4xl font-bold">10K+</div>
              <div className="mt-2 text-sm text-muted-foreground">Events Hosted</div>
            </div>
            <div className="text-center">
              <div className="text-4xl font-bold">50K+</div>
              <div className="mt-2 text-sm text-muted-foreground">Happy Users</div>
            </div>
            <div className="text-center">
              <div className="text-4xl font-bold">99%</div>
              <div className="mt-2 text-sm text-muted-foreground">Satisfaction Rate</div>
            </div>
          </div>
        </div>
      </div> */}

      {/* Feature Highlights */}
      <div className="container mx-auto px-4 py-16">
        <div className="mx-auto max-w-2xl text-center">
          <h2 className="text-3xl font-bold tracking-tight sm:text-4xl">
            Everything you need to run successful events
          </h2>
          <p className="mt-4 text-muted-foreground">
            Powerful features to help you manage events of any size
          </p>
        </div>

        <div className="mt-16 grid gap-8 md:grid-cols-2">
          <div className="flex items-start gap-4">
            <div className="rounded-lg bg-primary/10 p-2">
              <Zap className="h-6 w-6 text-primary" />
            </div>
            <div>
              <h3 className="font-semibold">Real-time Updates</h3>
              <p className="mt-1 text-sm text-muted-foreground">
                Stay informed with instant notifications and live event updates.
              </p>
            </div>
          </div>

          <div className="flex items-start gap-4">
            <div className="rounded-lg bg-primary/10 p-2">
              <CheckCircle className="h-6 w-6 text-primary" />
            </div>
            <div>
              <h3 className="font-semibold">Easy Check-ins</h3>
              <p className="mt-1 text-sm text-muted-foreground">
                Streamlined check-in process with QR codes and mobile support.
              </p>
            </div>
          </div>

          <div className="flex items-start gap-4">
            <div className="rounded-lg bg-primary/10 p-2">
              <Clock className="h-6 w-6 text-primary" />
            </div>
            <div>
              <h3 className="font-semibold">Time Management</h3>
              <p className="mt-1 text-sm text-muted-foreground">
                Schedule and coordinate multiple events with ease.
              </p>
            </div>
          </div>

          <div className="flex items-start gap-4">
            <div className="rounded-lg bg-primary/10 p-2">
              <Users className="h-6 w-6 text-primary" />
            </div>
            <div>
              <h3 className="font-semibold">Team Collaboration</h3>
              <p className="mt-1 text-sm text-muted-foreground">
                Work together with team members and coordinate responsibilities.
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* CTA Section */}
      <div className="border-t">
        <div className="container mx-auto px-4 py-16">
          <div className="relative overflow-hidden rounded-3xl bg-gradient-to-r from-primary to-primary/80 px-6 py-20 text-center shadow-xl">
            <div className="relative z-10">
              <h2 className="mx-auto max-w-2xl text-3xl font-bold text-white sm:text-4xl">
                Ready to transform your events?
              </h2>
              <p className="mx-auto mt-4 max-w-xl text-lg text-white/90">
                Join thousands of event organizers who trust our platform.
              </p>
              <div className="mt-8 flex justify-center gap-4">
                <Link href="/sign-up">
                  <Button size="lg" variant="secondary" className="gap-2">
                    Get Started Now <ArrowRight className="h-4 w-4" />
                  </Button>
                </Link>
              </div>
            </div>
            {/* Decorative elements */}
            <div className="absolute left-1/2 top-0 h-[120%] w-[120%] -translate-x-1/2 -translate-y-[10%] rotate-12 bg-white/5" />
          </div>
        </div>
      </div>

      {/* Footer */}
      <footer className="mt-auto border-t">
        <div className="container mx-auto px-4 py-8">
          <div className="flex flex-col items-center justify-between gap-4 sm:flex-row">
            <div className="text-center sm:text-left">
              <p className="text-sm text-muted-foreground">
                 2024 Event Platform. All rights reserved.
              </p>
            </div>
            <div className="flex gap-4">
              <Link href="/privacy" className="text-sm text-muted-foreground hover:text-primary">
                Privacy Policy
              </Link>
              <Link href="/terms" className="text-sm text-muted-foreground hover:text-primary">
                Terms of Service
              </Link>
              <Link href="/contact" className="text-sm text-muted-foreground hover:text-primary">
                Contact Us
              </Link>
            </div>
          </div>
        </div>
      </footer>
    </div>
  );
}

================
File: src/app/sentry.client.config.ts
================
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  tracesSampleRate: 1.0,
  debug: process.env.NODE_ENV === "development",
  replaysOnErrorSampleRate: 1.0,
  replaysSessionSampleRate: 0.1,
  integrations: [
    Sentry.browserTracingIntegration(),
    Sentry.replayIntegration({
      maskAllText: true,
      blockAllMedia: true,
    }),
    Sentry.feedbackIntegration({
      colorScheme: "system",
    }),
  ],
});

================
File: src/components/activity/activity-feed.tsx
================
"use client";

import { useState, useEffect } from "react";
import { formatDistanceToNow } from "date-fns";
import { pusherClient } from "@/lib/pusher";
import { Activity, formatActivityMessage } from "@/lib/activity/notifications";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

interface ActivityFeedProps {
  eventId?: string;
  userId?: string;
  limit?: number;
}

export function ActivityFeed({ eventId, userId, limit = 20 }: ActivityFeedProps) {
  const [activities, setActivities] = useState<Activity[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchActivities = async () => {
      try {
        let response;
        if (eventId) {
          response = await fetch(`/api/events/${eventId}/activities?limit=${limit}`);
        } else if (userId) {
          response = await fetch(`/api/users/${userId}/activities?limit=${limit}`);
        }

        if (response?.ok) {
          const data = await response.json();
          setActivities(data);
        }
      } catch (error) {
        console.error("Error fetching activities:", error);
      } finally {
        setLoading(false);
      }
    };

    fetchActivities();
  }, [eventId, userId, limit]);

  useEffect(() => {
    if (!eventId && !userId) return;

    const channel = pusherClient.subscribe(
      eventId ? `event-${eventId}` : `user-${userId}`
    );

    channel.bind("new-activity", (data: Activity) => {
      setActivities((prev) => [data, ...prev].slice(0, limit));
    });

    return () => {
      channel.unbind_all();
      channel.unsubscribe();
    };
  }, [eventId, userId, limit]);

  if (loading) {
    return <div>Loading activities...</div>;
  }

  return (
    <ScrollArea className="h-[400px]">
      <div className="space-y-4 p-4">
        {activities.map((activity) => (
          <div
            key={activity.createdAt.toString()}
            className="flex items-start space-x-4"
          >
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger>
                  <Avatar>
                    <AvatarImage src={`https://avatar.vercel.sh/${activity.userId}`} />
                    <AvatarFallback>U</AvatarFallback>
                  </Avatar>
                </TooltipTrigger>
                <TooltipContent>
                  <p>User ID: {activity.userId}</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>

            <div className="flex-1 space-y-1">
              <p className="text-sm">
                <span className="font-medium">User </span>
                {formatActivityMessage(activity)}
              </p>
              {activity.metadata && Object.keys(activity.metadata).length > 0 && (
                <p className="text-xs text-muted-foreground">
                  {JSON.stringify(activity.metadata)}
                </p>
              )}
              <p className="text-xs text-muted-foreground">
                {formatDistanceToNow(new Date(activity.createdAt), {
                  addSuffix: true,
                })}
              </p>
            </div>
          </div>
        ))}
      </div>
    </ScrollArea>
  );
}

================
File: src/components/ads/AdSense.tsx
================
"use client";

import Script from "next/script";

interface AdSenseProps {
  publisherId: string;
}

export function AdSense({ publisherId }: AdSenseProps) {
  if (process.env.NODE_ENV !== "production") {
    return null;
  }

  return (
    <Script
      id="adsbygoogle-init"
      async
      src={`https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=${publisherId}`}
      crossOrigin="anonymous"
      strategy="afterInteractive"
      onError={(e) => {
        console.error("AdSense script failed to load:", e);
      }}
    />
  );
}

================
File: src/components/ads/AdUnit.tsx
================
"use client";

import { usePathname, useSearchParams } from "next/navigation";
import { useEffect, useRef } from "react";

declare global {
  interface Window {
    adsbygoogle: {
      push: (obj: unknown) => void;
    }[] | undefined;
  }
}

interface AdUnitProps {
  slot: string;
  format?: "auto" | "fluid" | "rectangle" | "horizontal" | "vertical";
  layout?: string;
  fullWidthResponsive?: boolean;
  style?: React.CSSProperties;
}

const AdUnit = ({
  slot,
  format = "vertical",
  layout,
  fullWidthResponsive = true,
  style
}: AdUnitProps) => {
  const adRef = useRef<HTMLModElement>(null);
  const pathname = usePathname();
  const searchParams = useSearchParams();

  useEffect(() => {
    const loadAd = () => {
      const intervalId = setInterval(() => {
        try {
          if (typeof window !== "undefined") {
            if (!window.adsbygoogle) {
              window.adsbygoogle = [];
            }
            window.adsbygoogle.push();
            clearInterval(intervalId);
          }
        } catch (error) {
          console.error("AdSense error:", error);
          clearInterval(intervalId);
        }
      }, 300);

      return intervalId;
    };

    // Initial ad load
    const intervalId = loadAd();

    // Cleanup on unmount or route change
    return () => {
      if (intervalId) clearInterval(intervalId);
      
      // Clean up the ad slot
      if (adRef.current) {
        adRef.current.innerHTML = '';
      }
    };
  }, [pathname, searchParams]);

  return (
    <ins
      ref={adRef}
      className="adsbygoogle"
      style={{
        display: "block",
        textAlign: "center",
        minHeight: "100px",
        backgroundColor: process.env.NODE_ENV === "development" ? "#f0f0f0" : "transparent",
        border: process.env.NODE_ENV === "development" ? "1px dashed #ccc" : "none",
        margin: "20px auto",
        maxWidth: "100%",
        overflow: "hidden",
        ...style
      }}
      data-ad-client={process.env.NEXT_PUBLIC_GOOGLE_ADS_CLIENT_ID}
      data-ad-slot={slot}
      data-ad-format={format}
      data-ad-layout={layout}
      data-full-width-responsive={fullWidthResponsive}
      data-adtest={process.env.NODE_ENV === "development" ? "on" : "off"}
    />
  );
};

export default AdUnit;

================
File: src/components/calendar/event-calendar.tsx
================
"use client";

import { useEffect, useState } from "react";
import {
  Calendar,
  Views,
  DateLocalizer,
  momentLocalizer,
} from "react-big-calendar";
import moment from "moment";
import "react-big-calendar/lib/css/react-big-calendar.css";
import { Card } from "@/components/ui/card";
import { useRouter } from "next/navigation";

const localizer = momentLocalizer(moment);

interface Event {
  id: string;
  title: string;
  start: Date;
  end: Date;
}

export function EventCalendar() {
  const [events, setEvents] = useState<Event[]>([]);
  const router = useRouter();

  useEffect(() => {
    const fetchEvents = async () => {
      try {
        const response = await fetch("/api/events");
        const data = await response.json();
        const formattedEvents = data.map((event: any) => ({
          id: event.id,
          title: event.title,
          start: new Date(event.startDate),
          end: new Date(event.endDate),
        }));
        setEvents(formattedEvents);
      } catch (error) {
        console.error("Failed to fetch events:", error);
      }
    };

    fetchEvents();
  }, []);

  const handleEventClick = (event: Event) => {
    router.push(`/events/${event.id}`);
  };

  return (
    <Card className="p-4">
      <Calendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        style={{ height: "calc(100vh - 200px)" }}
        views={["month", "week", "day"]}
        onSelectEvent={handleEventClick}
        popup
      />
    </Card>
  );
}

================
File: src/components/dashboard/charts.tsx
================
"use client";

import { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  LineChart,
  Line,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell
} from 'recharts';
import { Skeleton } from "@/components/ui/skeleton";
import { MetricCard } from './metric-card';
import { Calendar } from "../ui/calendar";
import { Activity } from "@/lib/db/models/activity";
import { useQuery } from "@tanstack/react-query";

const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042'];

interface ChartData {
  attendanceData: {
    name: string;
    attendees: number;
    capacity: number;
  }[];
  registrationData: {
    name: string;
    registrations: number;
  }[];
  eventTypeData: {
    name: string;
    value: number;
  }[];
}

export function DashboardCharts() {
  const [data, setData] = useState<ChartData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchChartData = async () => {
      try {
        const response = await fetch('/api/events/stats/charts');
        if (!response.ok) {
          throw new Error('Failed to fetch chart data');
        }
        const chartData = await response.json();
        setData(chartData);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
      } finally {
        setLoading(false);
      }
    };

    fetchChartData();
  }, []);

  if (loading) {
    return (
      <Card className="col-span-4">
        <CardHeader>
          <CardTitle>Analytics Overview</CardTitle>
        </CardHeader>
        <CardContent>
          <Skeleton className="h-[300px] w-full" />
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card className="col-span-4">
        <CardHeader>
          <CardTitle>Analytics Overview</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex h-[300px] items-center justify-center text-muted-foreground">
            Failed to load chart data
          </div>
        </CardContent>
      </Card>
    );
  }

  if (!data) return null;

  return (
    <Card className="col-span-4">
      <CardHeader>
        <CardTitle>Analytics Overview</CardTitle>
      </CardHeader>
      <CardContent>
        <Tabs defaultValue="attendance" className="space-y-4">
          <TabsList>
            <TabsTrigger value="attendance">Attendance</TabsTrigger>
            <TabsTrigger value="registrations">Registrations</TabsTrigger>
            <TabsTrigger value="types">Event Types</TabsTrigger>
          </TabsList>
          
          <TabsContent value="attendance" className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={data.attendanceData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="name" />
                <YAxis />
                <Tooltip />
                <Line 
                  type="monotone" 
                  dataKey="attendees" 
                  stroke="#8884d8" 
                  strokeWidth={2}
                  name="Attendees"
                />
                <Line 
                  type="monotone" 
                  dataKey="capacity" 
                  stroke="#82ca9d" 
                  strokeWidth={2}
                  strokeDasharray="5 5"
                  name="Capacity"
                />
              </LineChart>
            </ResponsiveContainer>
          </TabsContent>

          <TabsContent value="registrations" className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart data={data.registrationData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="name" />
                <YAxis />
                <Tooltip />
                <Bar 
                  dataKey="registrations" 
                  fill="#8884d8" 
                  radius={[4, 4, 0, 0]}
                  name="Registrations"
                />
              </BarChart>
            </ResponsiveContainer>
          </TabsContent>

          <TabsContent value="types" className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie
                  data={data.eventTypeData}
                  cx="50%"
                  cy="50%"
                  labelLine={false}
                  label={({ name, percent }) => `${name} (${(percent * 100).toFixed(0)}%)`}
                  outerRadius={100}
                  fill="#8884d8"
                  dataKey="value"
                >
                  {data.eventTypeData.map((_, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Pie>
                <Tooltip />
              </PieChart>
            </ResponsiveContainer>
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  );
}

// export default function DashboardMetrics() {
//   const metrics = useQuery(['metrics'], async () => {
//     const response = await fetch('/api/events/stats');
//     return response.json();
//   });

//   return (
//     <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
//       <MetricCard
//         title="Total Events"
//         value={metrics.data.totalEvents}
//         icon={<Calendar />}
//       />
//       <MetricCard
//         title="Active Events"
//         value={metrics.data.activeEvents}
//         icon={<Activity />}
//       />
//       {/* Add more metric cards */}
//     </div>
//   );
// }

================
File: src/components/dashboard/event-stats.tsx
================
"use client";

import { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Tooltip, TooltipContent, TooltipTrigger } from "@/components/ui/tooltip";
import { CalendarCheck2, Users, TrendingUp, Percent } from "lucide-react";

interface StatsProps {
  stats: {
    totalEvents: number;
    upcomingEvents: number;
    totalAttendees: number;
    averageAttendance: number;
  };
  limits: {
    maxEvents: number;
    maxGuests: number;
  };
}

export function EventStats({ stats, limits }: StatsProps) {
  const [error, setError] = useState<string | null>(null);

  const eventProgress = (stats.totalEvents / limits.maxEvents) * 100;
  const isNearEventLimit = stats.totalEvents >= limits.maxEvents * 0.8;
  const isAtEventLimit = stats.totalEvents >= limits.maxEvents;

  if (error) {
    return (
      <div className="p-4 text-red-500">
        Error loading stats: {error}
      </div>
    );
  }

  return (
    <>
      <Card className={isAtEventLimit ? "border-destructive" : ""}>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <div className="space-y-1">
            <CardTitle className="text-sm font-medium">
              Total Events
            </CardTitle>
            {limits.maxEvents !== -1 && (
              <div className="flex items-center space-x-2">
                <Progress value={eventProgress} className="w-20 h-2" />
                <span className="text-xs text-muted-foreground">
                  {stats.totalEvents}/{limits.maxEvents}
                </span>
              </div>
            )}
          </div>
          <CalendarCheck2 className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="flex items-center space-x-2">
            <div className="text-2xl font-bold">{stats.totalEvents}</div>
            {isNearEventLimit && !isAtEventLimit && (
              <Tooltip>
                <TooltipTrigger>
                  <Badge variant="secondary" className="ml-2">
                    Near Limit
                  </Badge>
                </TooltipTrigger>
                <TooltipContent>
                  You're approaching your event limit
                </TooltipContent>
              </Tooltip>
            )}
            {isAtEventLimit && (
              <Tooltip>
                <TooltipTrigger>
                  <Badge variant="destructive" className="ml-2">
                    Limit Reached
                  </Badge>
                </TooltipTrigger>
                <TooltipContent>
                  Upgrade your plan to create more events
                </TooltipContent>
              </Tooltip>
            )}
          </div>
          <p className="text-xs text-muted-foreground">
            {limits.maxEvents === -1 ? "Unlimited events" : "Events this month"}
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">
            Upcoming Events
          </CardTitle>
          <TrendingUp className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{stats.upcomingEvents}</div>
          <p className="text-xs text-muted-foreground">
            Next 30 days
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <div className="space-y-1">
            <CardTitle className="text-sm font-medium">
              Total Attendees
            </CardTitle>
            {limits.maxGuests !== -1 && (
              <div className="text-xs text-muted-foreground">
                Max {limits.maxGuests} per event
              </div>
            )}
          </div>
          <Users className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{stats.totalAttendees}</div>
          <p className="text-xs text-muted-foreground">
            {limits.maxGuests === -1 ? "Unlimited guests" : "Confirmed attendees"}
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">
            Average Attendance
          </CardTitle>
          <Percent className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            {stats.averageAttendance}%
          </div>
          <p className="text-xs text-muted-foreground">
            Check-in rate
          </p>
        </CardContent>
      </Card>
    </>
  );
}

================
File: src/components/dashboard/metric-card.tsx
================
import { Card, CardContent } from "@/components/ui/card";
import { ReactNode } from "react";

interface MetricCardProps {
  title: string;
  value: number | string;
  icon?: ReactNode;
  description?: string;
  trend?: {
    value: number;
    isPositive: boolean;
  };
}

export function MetricCard({ title, value, icon, description, trend }: MetricCardProps) {
  return (
    <Card>
      <CardContent className="p-6">
        <div className="flex items-center justify-between space-x-4">
          <div className="flex items-center space-x-4">
            {icon && <div className="text-muted-foreground">{icon}</div>}
            <div>
              <p className="text-sm font-medium text-muted-foreground">{title}</p>
              <h3 className="text-2xl font-bold">{value}</h3>
              {description && (
                <p className="text-xs text-muted-foreground">{description}</p>
              )}
            </div>
          </div>
          {trend && (
            <div className={`text-sm ${trend.isPositive ? 'text-green-600' : 'text-red-600'}`}>
              {trend.isPositive ? '' : ''} {Math.abs(trend.value)}%
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}

================
File: src/components/dashboard/metrics.tsx
================
// src/components/dashboard/metrics.tsx
import { useQuery } from '@tanstack/react-query';
import { Calendar, Activity, Users, TrendingUp } from 'lucide-react';
import { MetricCard } from './metric-card';

interface MetricsData {
  totalEvents: number;
  activeEvents: number;
  totalAttendees: number;
  growthRate: number;
}

export function DashboardMetrics() {
  const { data, isLoading } = useQuery<MetricsData>({
    queryKey: ['metrics'],
    queryFn: async () => {
      const response = await fetch('/api/events/stats');
      if (!response.ok) {
        throw new Error('Failed to fetch metrics');
      }
      return response.json();
    }
  });

  if (isLoading) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {[...Array(4)].map((_, i) => (
          <div key={i} className="h-32 animate-pulse bg-muted rounded-lg" />
        ))}
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      <MetricCard
        title="Total Events"
        value={data?.totalEvents || 0}
        icon={<Calendar className="h-4 w-4" />}
        description="All time events"
      />
      <MetricCard
        title="Active Events"
        value={data?.activeEvents || 0}
        icon={<Activity className="h-4 w-4" />}
        description="Currently running"
      />
      <MetricCard
        title="Total Attendees"
        value={data?.totalAttendees || 0}
        icon={<Users className="h-4 w-4" />}
        description="Across all events"
      />
      <MetricCard
        title="Growth Rate"
        value={`${data?.growthRate || 0}%`}
        icon={<TrendingUp className="h-4 w-4" />}
        trend={{
          value: data?.growthRate || 0,
          isPositive: (data?.growthRate || 0) > 0
        }}
        description="vs last month"
      />
    </div>
  );
}

================
File: src/components/dashboard/recent-activity.tsx
================
// src/components/dashboard/recent-activity.tsx
"use client";

import { useEffect, useState } from "react";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { formatDistanceToNow } from "date-fns";
import Link from "next/link";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { 
  Calendar, 
  UserCheck, 
  UserMinus, 
  MessageSquare, 
  Edit,
  ExternalLink,
  Settings,
  Mail
} from "lucide-react";

interface Activity {
  id: string;
  type: string;
  userId: string;
  eventId: string;
  metadata?: {
    guestId?: string;
    guestName?: string;
    eventTitle?: string;
    changes?: string[];
    messageId?: string;
    messageContent?: string;
  };
  createdAt: string;
  user?: {
    name: string;
    avatar?: string;
    email: string;
  };
  event?: {
    title: string;
  };
}

export function RecentActivity() {
  const [activities, setActivities] = useState<Activity[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchActivities();
  }, []);

  const fetchActivities = async () => {
    try {
      const response = await fetch('/api/activities?limit=20');
      if (!response.ok) throw new Error('Failed to fetch activities');
      const data = await response.json();
      
      // Fetch user details for each activity
      const enrichedActivities = await Promise.all(
        data.map(async (activity: Activity) => {
          try {
            const userResponse = await fetch(`/api/users/${activity.userId}`);
            if (userResponse.ok) {
              const userData = await userResponse.json();
              return {
                ...activity,
                user: {
                  name: userData.name || 'Unknown User',
                  avatar: userData.imageUrl,
                  email: userData.emailAddress
                }
              };
            }
          } catch (error) {
            console.error(`Error fetching user data for ${activity.userId}:`, error);
          }
          return activity;
        })
      );

      setActivities(enrichedActivities);
    } catch (error) {
      console.error("Error fetching activities:", error);
    } finally {
      setLoading(false);
    }
  };

  const getActivityIcon = (type: string) => {
    const icons = {
      'event.created': <Calendar className="h-4 w-4" />,
      'event.updated': <Edit className="h-4 w-4" />,
      'event.cancelled': <UserMinus className="h-4 w-4" />,
      'guest.invited': <Mail className="h-4 w-4" />,
      'guest.confirmed': <UserCheck className="h-4 w-4" />,
      'guest.declined': <UserMinus className="h-4 w-4" />,
      'guest.checked_in': <UserCheck className="h-4 w-4" />,
      'guest.removed': <UserMinus className="h-4 w-4" />,
      'message.sent': <MessageSquare className="h-4 w-4" />,
      'settings.updated': <Settings className="h-4 w-4" />,
    };
    return icons[type as keyof typeof icons] || <Calendar className="h-4 w-4" />;
  };

  const getActivityColor = (type: string) => {
    const colors = {
      'event.created': "bg-green-100 text-green-800",
      'event.updated': "bg-yellow-100 text-yellow-800",
      'event.cancelled': "bg-red-100 text-red-800",
      'guest.invited': "bg-blue-100 text-blue-800",
      'guest.confirmed': "bg-green-100 text-green-800",
      'guest.declined': "bg-red-100 text-red-800",
      'guest.checked_in': "bg-green-100 text-green-800",
      'guest.removed': "bg-red-100 text-red-800",
      'message.sent': "bg-purple-100 text-purple-800",
      'settings.updated': "bg-yellow-100 text-yellow-800",
    };
    return colors[type as keyof typeof colors] || "bg-gray-100 text-gray-800";
  };

  const formatActivityMessage = (activity: Activity) => {
    switch (activity.type) {
      case 'event.created':
        return `created event "${activity.metadata?.eventTitle}"`;
      case 'event.updated':
        return `updated event details (${activity.metadata?.changes?.join(', ')})`;
      case 'event.cancelled':
        return `cancelled event "${activity.metadata?.eventTitle}"`;
      case 'guest.invited':
        return `invited ${activity.metadata?.guestName} to the event`;
      case 'guest.confirmed':
        return `confirmed attendance for ${activity.metadata?.guestName}`;
      case 'guest.declined':
        return `declined attendance for ${activity.metadata?.guestName}`;
      case 'guest.checked_in':
        return `checked in ${activity.metadata?.guestName}`;
      case 'guest.removed':
        return `removed ${activity.metadata?.guestName} from the event`;
      case 'message.sent':
        return `sent a message: "${activity.metadata?.messageContent}"`;
      case 'settings.updated':
        return `updated event settings`;
      default:
        return 'performed an action';
    }
  };

  if (loading) {
    return (
      <div className="space-y-4">
        {[1, 2, 3].map((index) => (
          <div
            key={index}
            className="flex items-start space-x-4 animate-pulse"
          >
            <div className="h-10 w-10 rounded-full bg-gray-200" />
            <div className="space-y-2 flex-1">
              <div className="h-4 w-3/4 bg-gray-200 rounded" />
              <div className="h-3 w-1/2 bg-gray-200 rounded" />
            </div>
          </div>
        ))}
      </div>
    );
  }

  return (
    <ScrollArea className="h-[400px]">
      <div className="space-y-4 pr-4">
        {activities.map((activity) => (
          <div
            key={activity.id}
            className="flex items-start space-x-4 border-b pb-4 last:border-0"
          >
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger>
                  <Avatar>
                    <AvatarImage 
                      src={activity.user?.avatar || `https://api.dicebear.com/7.x/initials/svg?seed=${activity.userId}`} 
                    />
                    <AvatarFallback>
                      {activity.user?.name?.[0] || 'U'}
                    </AvatarFallback>
                  </Avatar>
                </TooltipTrigger>
                <TooltipContent>
                  <div>{activity.user?.name || 'User'}</div>
                  <div className="text-xs text-muted-foreground">
                    {activity.user?.email || activity.userId}
                  </div>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
            
            <div className="flex-1 space-y-1">
              <div className="flex items-center gap-2">
                <Badge className={getActivityColor(activity.type)}>
                  <span className="flex items-center gap-1">
                    {getActivityIcon(activity.type)}
                    {activity.type.split('.')[0]}
                  </span>
                </Badge>
                <span className="text-xs text-muted-foreground">
                  {formatDistanceToNow(new Date(activity.createdAt), { addSuffix: true })}
                </span>
              </div>
              
              <div className="text-sm">
                <span className="font-medium">{activity.user?.name || 'User'} </span>
                {formatActivityMessage(activity)}
              </div>
            </div>

            {activity.eventId && (
              <Link
                href={`/events/${activity.eventId}`}
                className="shrink-0 hover:text-primary"
              >
                <ExternalLink className="h-4 w-4" />
              </Link>
            )}
          </div>
        ))}
      </div>
    </ScrollArea>
  );
}

================
File: src/components/dashboard/upcoming-events.tsx
================
"use client";

import { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Calendar, Clock, MapPin, Users } from "lucide-react";
import { format } from "date-fns";
import Link from "next/link";
import { LoadingSpinner } from "@/components/ui/loading-state";

interface Event {
  id: string;
  title: string;
  startDate: string;
  endDate: string;
  location: {
    venue: string;
    address: string;
  };
  attendees: {
    confirmed: number;
    total: number;
  };
  status: "upcoming" | "ongoing" | "ended";
  visibility: "public" | "private";
}

interface ApiResponse {
  events: Event[];
  success: boolean;
  error?: string;
}

export function UpcomingEvents({maxEvents: maxEvents = 3}: {maxEvents?: number}) {
  const [events, setEvents] = useState<Event[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchUpcomingEvents = async () => {
      try {
        const response = await fetch('/api/events/upcoming');
        if (!response.ok) {
          throw new Error('Failed to fetch upcoming events');
        }
        const data: ApiResponse = await response.json();
        
        if (!data.success) {
          throw new Error(data.error || 'Failed to fetch events');
        }

        setEvents(data.events);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
        console.error('Error fetching upcoming events:', err);
      } finally {
        setLoading(false);
      }
    };

    fetchUpcomingEvents();
  }, []);

  const getStatusColor = (status: string) => {
    const colors = {
      upcoming: "bg-blue-100 text-blue-800",
      ongoing: "bg-green-100 text-green-800",
      ended: "bg-gray-100 text-gray-800"
    };
    return colors[status as keyof typeof colors];
  };

  if (loading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Upcoming Events</CardTitle>
        </CardHeader>
        <CardContent className="flex items-center justify-center h-[400px]">
          <LoadingSpinner />
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Upcoming Events</CardTitle>
        </CardHeader>
        <CardContent className="flex items-center justify-center h-[400px] text-muted-foreground">
          {error}
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle>Upcoming Events</CardTitle>
        <Link href="/events">
          <Button variant="outline" size="sm">View All</Button>
        </Link>
      </CardHeader>
      <CardContent>
        <ScrollArea className="h-[400px] pr-4">
          {events.length === 0 ? (
            <div className="flex items-center justify-center h-[300px] text-muted-foreground">
              No upcoming events
            </div>
          ) : (
            <div className="space-y-4">
              {events.map((event) => (
                <Link 
                  key={event.id} 
                  href={`/events/${event.id}`}
                  className="block"
                >
                  <div className="rounded-lg border p-3 hover:bg-accent transition-colors">
                    <div className="flex items-start justify-between">
                      <h3 className="font-medium">{event.title}</h3>
                      <Badge className={getStatusColor(event.status)}>
                        {event.status}
                      </Badge>
                    </div>
                    
                    <div className="mt-2 space-y-1">
                      <div className="flex items-center text-sm text-muted-foreground">
                        <Calendar className="mr-2 h-4 w-4" />
                        {format(new Date(event.startDate), "PPP")}
                      </div>
                      <div className="flex items-center text-sm text-muted-foreground">
                        <Clock className="mr-2 h-4 w-4" />
                        {format(new Date(event.startDate), "p")} - 
                        {format(new Date(event.endDate), "p")}
                      </div>
                      <div className="flex items-center text-sm text-muted-foreground">
                        <MapPin className="mr-2 h-4 w-4" />
                        {event.location.venue}
                      </div>
                      <div className="flex items-center text-sm text-muted-foreground">
                        <Users className="mr-2 h-4 w-4" />
                        {event.attendees.confirmed} / {event.attendees.total} attendees
                      </div>
                    </div>
                  </div>
                </Link>
              ))}
            </div>
          )}
        </ScrollArea>
      </CardContent>
    </Card>
  );
}

================
File: src/components/error-boundary/global-error.tsx
================
"use client"

import { useEffect } from 'react';
import * as Sentry from '@sentry/nextjs';
import { Button } from '@/components/ui/button';
import { FallbackProps } from 'react-error-boundary';

export function GlobalError({ error, resetErrorBoundary }: FallbackProps) {
  useEffect(() => {
    // Log to error reporting service
    Sentry.captureException(error);
  }, [error]);

  return (
    <div className="flex h-screen flex-col items-center justify-center space-y-4">
      <div className="text-center space-y-2">
        <h1 className="text-4xl font-bold text-destructive">Something went wrong!</h1>
        <p className="text-muted-foreground">
          We apologize for the inconvenience. Please try again.
        </p>
      </div>
      <div className="flex space-x-4">
        <Button onClick={() => window.location.reload()}>Refresh Page</Button>
        <Button variant="outline" onClick={resetErrorBoundary}>Try Again</Button>
      </div>
      {process.env.NODE_ENV === 'development' && (
        <div className="mt-4 max-w-xl overflow-auto rounded-md bg-muted p-4">
          <pre className="text-sm text-destructive">{error.message}</pre>
          <pre className="text-xs text-muted-foreground">{error.stack}</pre>
        </div>
      )}
    </div>
  );
}

================
File: src/components/error-boundary/sentry-error-boundary.tsx
================
'use client';

import * as Sentry from "@sentry/nextjs";
import { Component, ReactNode } from "react";

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
}

export class SentryErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };

  public static getDerivedStateFromError(): State {
    return { hasError: true };
  }

  public componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    Sentry.captureException(error, {
      contexts: { react: { componentStack: errorInfo.componentStack } },
    });
  }

  public render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="flex min-h-[400px] items-center justify-center">
          <div className="text-center">
            <h2 className="text-xl font-semibold">Something went wrong</h2>
            <button
              className="mt-4 rounded bg-primary px-4 py-2 text-white"
              onClick={() => this.setState({ hasError: false })}
            >
              Try again
            </button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

================
File: src/components/error-boundary/with-error-boundary.tsx
================
import { ErrorBoundary, FallbackProps } from 'react-error-boundary';
import { GlobalError } from './global-error';

export function withErrorBoundary<P extends object>(
  Component: React.ComponentType<P>,
  fallback: React.ComponentType<FallbackProps> = GlobalError
) {
  return function WithErrorBoundary(props: P) {
    return (
      <ErrorBoundary FallbackComponent={fallback}>
        <Component {...props} />
      </ErrorBoundary>
    );
  };
}

================
File: src/components/events/check-in.tsx
================
"use client";

import { useState } from "react";
import { QRCodeSVG } from "qrcode.react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { useToast } from "@/hooks/use-toast";
import { 
  QrCode, 
  UserCheck,
  Search,
  UserX 
} from "lucide-react";

interface CheckInProps {
  eventId: string;
  onCheckedIn?: () => void;
}

export function CheckIn({ eventId, onCheckedIn }: CheckInProps) {
  const [searchQuery, setSearchQuery] = useState("");
  const [scanning, setScanning] = useState(false);
  const { toast } = useToast();
  const checkInUrl = `${window.location.origin}/events/${eventId}/check-in`;

  const handleCheckIn = async (guestId: string) => {
    try {
      const response = await fetch(`/api/events/${eventId}/check-in`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ guestId }),
      });

      if (!response.ok) throw new Error("Check-in failed");

      const data = await response.json();
      toast({
        title: "Checked In Successfully",
        description: `${data.guest.name} has been checked in.`,
      });

      if (onCheckedIn) onCheckedIn();
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Check-in Failed",
        description: "Unable to check in guest. Please try again.",
      });
    }
  };

  const searchGuests = async () => {
    try {
      const response = await fetch(
        `/api/events/${eventId}/guests/search?q=${encodeURIComponent(searchQuery)}`
      );
      if (!response.ok) throw new Error("Search failed");
      return await response.json();
    } catch (error) {
      console.error("Error searching guests:", error);
      return [];
    }
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div className="flex gap-2">
          <Input
            placeholder="Search guests..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="w-64"
          />
          <Button onClick={searchGuests}>
            <Search className="h-4 w-4 mr-2" />
            Search
          </Button>
        </div>

        <Dialog>
          <DialogTrigger asChild>
            <Button variant="outline">
              <QrCode className="h-4 w-4 mr-2" />
              Show QR Code
            </Button>
          </DialogTrigger>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Event Check-in QR Code</DialogTitle>
            </DialogHeader>
            <div className="flex justify-center p-4">
              <QRCodeSVG value={checkInUrl} size={256} />
            </div>
            <p className="text-center text-sm text-muted-foreground">
              Scan this QR code to check in to the event
            </p>
          </DialogContent>
        </Dialog>
      </div>

      {/* Guest search results and check-in UI would go here */}
    </div>
  );
}

================
File: src/components/events/event-card.tsx
================
// src/components/events/event-card.tsx
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Calendar, Clock, MapPin, Users } from "lucide-react";
import { format } from "date-fns";
import Link from "next/link";

interface EventCardProps {
  event: {
    id: string;
    title: string;
    description: string;
    startDate: Date;
    endDate: Date;
    location: {
      venue: string;
    };
    capacity: number;
    status: string;
  };
}

export function EventCard({ event }: EventCardProps) {
  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle className="line-clamp-1">{event.title}</CardTitle>
          <Badge variant={event.status === "published" ? "default" : "secondary"}>
            {event.status}
          </Badge>
        </div>
        <CardDescription className="line-clamp-2">
          {event.description}
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-2">
        <div className="flex items-center space-x-2 text-sm">
          <Calendar className="h-4 w-4" />
          <span>{format(new Date(event.startDate), "PPP")}</span>
        </div>
        <div className="flex items-center space-x-2 text-sm">
          <Clock className="h-4 w-4" />
          <span>{format(new Date(event.startDate), "p")}</span>
        </div>
        <div className="flex items-center space-x-2 text-sm">
          <MapPin className="h-4 w-4" />
          <span>{event.location?.venue}</span>
        </div>
        <div className="flex items-center space-x-2 text-sm">
          <Users className="h-4 w-4" />
          <span>{event.capacity} attendees</span>
        </div>
      </CardContent>
      <CardFooter className="flex justify-between">
        <Link href={`/events/${event.id}/edit`}>
          <Button variant="outline">Edit</Button>
        </Link>
        <Link href={`/events/${event.id}`}>
          <Button>View Details</Button>
        </Link>
      </CardFooter>
    </Card>
  );
}

================
File: src/components/events/event-chat.tsx
================
"use client";

import { useEffect, useRef, useState } from "react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { format } from "date-fns";
import { pusherClient } from "@/lib/pusher";
import { useUser } from "@clerk/nextjs";

interface Message {
  id: string;
  content: string;
  senderId: string;
  senderName: string;
  senderAvatar?: string;
  createdAt: string;
}

export function EventChat({ eventId }: { eventId: string }) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [newMessage, setNewMessage] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const scrollRef = useRef<HTMLDivElement>(null);
  const { user } = useUser();

  useEffect(() => {
    fetchMessages();
    const channel = pusherClient.subscribe(`event-${eventId}`);
    
    channel.bind("new-message", (message: Message) => {
      setMessages((current) => [...current, message]);
      scrollToBottom();
    });

    return () => {
      pusherClient.unbind_all();
      pusherClient.unsubscribe(`event-${eventId}`);
    };
  }, [eventId]);

  const fetchMessages = async () => {
    try {
      const response = await fetch(`/api/events/${eventId}/chat`);
      const data = await response.json();
      setMessages(data);
      scrollToBottom();
    } catch (error) {
      console.error("Error fetching messages:", error);
    }
  };

  const scrollToBottom = () => {
    if (scrollRef.current) {
      scrollRef.current.scrollIntoView({ behavior: "smooth" });
    }
  };

  const sendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newMessage.trim() || isLoading) return;

    setIsLoading(true);
    try {
      await fetch(`/api/events/${eventId}/chat`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          content: newMessage,
          senderName: user?.fullName,
          senderAvatar: user?.imageUrl,
        }),
      });
      setNewMessage("");
    } catch (error) {
      console.error("Error sending message:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex flex-col h-[600px]">
      <ScrollArea className="flex-1 p-4">
        <div className="space-y-4">
          {messages.map((message) => (
            <div
              key={message.id}
              className={`flex items-start space-x-2 ${
                message.senderId === user?.id ? "justify-end" : ""
              }`}
            >
              {message.senderId !== user?.id && (
                <Avatar>
                  <AvatarImage src={message.senderAvatar} />
                  <AvatarFallback>
                    {message.senderName?.[0]?.toUpperCase()}
                  </AvatarFallback>
                </Avatar>
              )}
              <div
                className={`flex flex-col space-y-1 ${
                  message.senderId === user?.id ? "items-end" : ""
                }`}
              >
                <div
                  className={`px-4 py-2 rounded-lg ${
                    message.senderId === user?.id
                      ? "bg-primary text-primary-foreground"
                      : "bg-muted"
                  }`}
                >
                  <p>{message.content}</p>
                </div>
                <span className="text-xs text-muted-foreground">
                  {format(new Date(message.createdAt), "p")}
                </span>
              </div>
            </div>
          ))}
          <div ref={scrollRef} />
        </div>
      </ScrollArea>
      <form onSubmit={sendMessage} className="p-4 border-t">
        <div className="flex space-x-2">
          <Input
            value={newMessage}
            onChange={(e) => setNewMessage(e.target.value)}
            placeholder="Type your message..."
            disabled={isLoading}
          />
          <Button type="submit" disabled={isLoading}>
            Send
          </Button>
        </div>
      </form>
    </div>
  );
}

================
File: src/components/events/event-form.tsx
================
"use client";

import * as z from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { cn } from "@/lib/utils";
import { format } from "date-fns";
import { CalendarIcon } from "lucide-react";
import { useState } from "react";
import { useRouter } from "next/navigation";
import { useToast } from "@/hooks/use-toast";

const formSchema = z.object({
  title: z.string().min(2, "Title must be at least 2 characters").max(100),
  description: z.string().min(10, "Description must be at least 10 characters"),
  startDate: z.date({
    required_error: "Start date is required",
  }),
  endDate: z.date({
    required_error: "End date is required",
  }),
  venue: z.string().min(2, "Venue is required"),
  address: z.string().min(5, "Address is required"),
  capacity: z.string().transform(Number),
  visibility: z.enum(["public", "private"]),
  recurring: z.enum(["none", "daily", "weekly", "monthly"])
}).refine(data => {
  return data.endDate >= data.startDate;
}, {
  message: "End date must be after start date",
  path: ["endDate"],
});

interface EventFormProps {
  event?: any;
  isEditing?: boolean;
}

export function EventForm({ event, isEditing = false }: EventFormProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const { toast } = useToast();

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: event?.title || "",
      description: event?.description || "",
      venue: event?.location?.venue || "",
      address: event?.location?.address || "",
      capacity: event?.capacity || "0",
      visibility: event?.visibility || "private",
      recurring: event?.recurring?.pattern || "none",
      startDate: event?.startDate ? new Date(event.startDate) : undefined,
      endDate: event?.endDate ? new Date(event.endDate) : undefined,
    },
  });

  async function onSubmit(values: z.infer<typeof formSchema>) {
    try {
      setIsLoading(true);
      const url = isEditing ? `/api/events/${event.id}` : "/api/events";
      const method = isEditing ? "PATCH" : "POST";

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(values),
      });

      if (!response.ok) {
        throw new Error(isEditing ? "Failed to update event" : "Failed to create event");
      }

      const data = await response.json();
      router.push(`/events/${data.id}`);
      router.refresh();
    } catch (error) {
      console.error(error);
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Event Title</FormLabel>
              <FormControl>
                <Input placeholder="Tech Conference 2024" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Enter event description"
                  className="h-32"
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="grid gap-6 md:grid-cols-2">
          <FormField
            control={form.control}
            name="startDate"
            render={({ field }) => (
              <FormItem className="flex flex-col">
                <FormLabel>Start Date</FormLabel>
                <Popover>
                  <PopoverTrigger asChild>
                    <FormControl>
                      <Button
                        variant="outline"
                        className={cn(
                          "w-full pl-3 text-left font-normal",
                          !field.value && "text-muted-foreground"
                        )}
                      >
                        {field.value ? (
                          format(field.value, "PPP")
                        ) : (
                          <span>Pick a date</span>
                        )}
                        <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                      </Button>
                    </FormControl>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="start">
                    <Calendar
                      mode="single"
                      selected={field.value}
                      onSelect={field.onChange}
                      disabled={(date) =>
                        date < new Date() || date < new Date("1900-01-01")
                      }
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="endDate"
            render={({ field }) => (
              <FormItem className="flex flex-col">
                <FormLabel>End Date</FormLabel>
                <Popover>
                  <PopoverTrigger asChild>
                    <FormControl>
                      <Button
                        variant="outline"
                        className={cn(
                          "w-full pl-3 text-left font-normal",
                          !field.value && "text-muted-foreground"
                        )}
                      >
                        {field.value ? (
                          format(field.value, "PPP")
                        ) : (
                          <span>Pick a date</span>
                        )}
                        <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                      </Button>
                    </FormControl>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="start">
                    <Calendar
                      mode="single"
                      selected={field.value}
                      onSelect={field.onChange}
                      disabled={(date) =>
                        date < new Date() || date < new Date("1900-01-01")
                      }
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <div className="grid gap-6 md:grid-cols-2">
          <FormField
            control={form.control}
            name="venue"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Venue Name</FormLabel>
                <FormControl>
                  <Input placeholder="Convention Center" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="address"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Address</FormLabel>
                <FormControl>
                  <Input placeholder="123 Main St, City" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <div className="grid gap-6 md:grid-cols-3">
          <FormField
            control={form.control}
            name="capacity"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Capacity</FormLabel>
                <FormControl>
                  <Input
                    type="number"
                    placeholder="100"
                    {...field}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="visibility"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Visibility</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                >
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select visibility" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="public">Public</SelectItem>
                    <SelectItem value="private">Private</SelectItem>
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="recurring"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Recurring</FormLabel>
                <Select
                  onValueChange={field.onChange}
                  defaultValue={field.value}
                >
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select pattern" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="none">None</SelectItem>
                    <SelectItem value="daily">Daily</SelectItem>
                    <SelectItem value="weekly">Weekly</SelectItem>
                    <SelectItem value="monthly">Monthly</SelectItem>
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <Button type="submit" className="w-full" disabled={isLoading}>
        {isLoading 
            ? (isEditing ? "Updating..." : "Creating...") 
            : (isEditing ? "Update Event" : "Create Event")
          }
        </Button>
      </form>
    </Form>
  );
}

================
File: src/components/events/guest-list.tsx
================
"use client";

import { useState, useEffect } from "react";
import { Search } from "lucide-react";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import { useToast } from "@/hooks/use-toast";
import { pusherClient } from "@/lib/pusher";

interface Guest {
  id: string;
  name: string;
  email: string;
  status: "invited" | "confirmed" | "declined" | "waitlist";
  role: "attendee" | "coHost" | "moderator";
  checkedIn: boolean;
  checkedInAt?: string;
}

export function GuestList({ eventId }: { eventId: string }) {
  const [guests, setGuests] = useState<Guest[]>([]);
  const [searchQuery, setSearchQuery] = useState("");
  const [loading, setLoading] = useState(true);
  const { toast } = useToast();

  useEffect(() => {
    fetchGuests();

    // Initialize Pusher only if we have the required credentials
    if (process.env.NEXT_PUBLIC_PUSHER_APP_KEY && process.env.NEXT_PUBLIC_PUSHER_CLUSTER) {
      try {
        const channel = pusherClient.subscribe(`event-${eventId}`);
        
        channel.bind("guest-updated", (updatedGuest: Guest) => {
          setGuests(currentGuests =>
            currentGuests.map(guest =>
              guest.id === updatedGuest.id ? updatedGuest : guest
            )
          );
        });

        channel.bind("guest-added", (newGuest: Guest) => {
          setGuests(currentGuests => [...currentGuests, newGuest]);
        });

        channel.bind("guest-removed", (removedGuestId: string) => {
          setGuests(currentGuests =>
            currentGuests.filter(guest => guest.id !== removedGuestId)
          );
        });

        return () => {
          channel.unbind_all();
          channel.unsubscribe();
        };
      } catch (error) {
        console.error("Pusher initialization error:", error);
      }
    }
  }, [eventId]);

  const fetchGuests = async () => {
    try {
      const response = await fetch(`/api/events/${eventId}/guests`);
      if (!response.ok) throw new Error("Failed to fetch guests");
      const data = await response.json();
      setGuests(data);
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to load guest list",
        variant: "destructive",
      });
    } finally {
      setLoading(false);
    }
  };

  const updateGuestStatus = async (guestId: string, status: Guest["status"]) => {
    try {
      const response = await fetch(`/api/events/${eventId}/guests/${guestId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ status }),
      });

      if (!response.ok) throw new Error("Failed to update guest status");

      toast({
        title: "Success",
        description: "Guest status updated",
      });

      fetchGuests(); // Refresh the guest list
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to update guest status",
        variant: "destructive",
      });
    }
  };

  const removeGuest = async (guestId: string) => {
    try {
      const response = await fetch(`/api/events/${eventId}/guests/${guestId}`, {
        method: "DELETE",
      });

      if (!response.ok) throw new Error("Failed to remove guest");

      toast({
        title: "Success",
        description: "Guest removed successfully",
      });

      fetchGuests(); // Refresh the guest list
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to remove guest",
        variant: "destructive",
      });
    }
  };

  const filteredGuests = guests.filter(
    guest =>
      guest.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
      guest.email.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const getStatusColor = (status: Guest["status"]) => {
    const colors = {
      invited: "bg-blue-100 text-blue-800",
      confirmed: "bg-green-100 text-green-800",
      declined: "bg-red-100 text-red-800",
      waitlist: "bg-yellow-100 text-yellow-800",
    };
    return colors[status];
  };

  if (loading) {
    return <div>Loading guest list...</div>;
  }

  return (
    <div className="space-y-4">
      <div className="relative">
        <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
        <Input
          placeholder="Search guests..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="pl-8"
        />
      </div>

      <ScrollArea className="h-[400px] pr-4">
        <div className="space-y-2">
          {filteredGuests.map((guest) => (
            <div
              key={guest.id}
              className="flex items-center justify-between rounded-lg border p-2"
            >
              <div className="flex items-center gap-2">
                <Avatar>
                  <AvatarImage src={`https://avatar.vercel.sh/${guest.email}`} />
                  <AvatarFallback>{guest.name[0]}</AvatarFallback>
                </Avatar>
                <div>
                  <div className="font-medium">{guest.name}</div>
                  <div className="text-sm text-muted-foreground">
                    {guest.email}
                  </div>
                </div>
              </div>

              <div className="flex items-center gap-2">
                <Badge className={getStatusColor(guest.status)}>
                  {guest.status}
                </Badge>
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="ghost" size="sm">
                      
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end">
                    <DropdownMenuLabel>Actions</DropdownMenuLabel>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem
                      onClick={() => updateGuestStatus(guest.id, "confirmed")}
                    >
                      Confirm
                    </DropdownMenuItem>
                    <DropdownMenuItem
                      onClick={() => updateGuestStatus(guest.id, "declined")}
                    >
                      Decline
                    </DropdownMenuItem>
                    <DropdownMenuItem
                      onClick={() => updateGuestStatus(guest.id, "waitlist")}
                    >
                      Move to Waitlist
                    </DropdownMenuItem>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem
                      className="text-red-600"
                      onClick={() => removeGuest(guest.id)}
                    >
                      Remove
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </div>
            </div>
          ))}
        </div>
      </ScrollArea>
    </div>
  );
}

================
File: src/components/events/share-event.tsx
================
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { 
  Facebook, 
  Twitter, 
  Linkedin, 
  Mail, 
  Link as LinkIcon,
  Check,
  Copy,
  Share2
} from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Textarea } from "@/components/ui/textarea";
import { Separator } from "@/components/ui/separator";

interface ShareEventProps {
  event: {
    id: string;
    title: string;
    description: string;
    startDate: string;
    location: {
      venue: string;
      address: string;
    };
  };
}

export function ShareEvent({ event }: ShareEventProps) {
  const [copied, setCopied] = useState(false);
  const [inviteEmails, setInviteEmails] = useState("");
  const [inviteMessage, setInviteMessage] = useState("");
  const { toast } = useToast();
  const eventUrl = `${window.location.origin}/events/${event.id}`;

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(eventUrl);
      setCopied(true);
      toast({
        description: "Link copied to clipboard",
        duration: 2000,
      });
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error("Failed to copy text: ", err);
      toast({
        variant: "destructive",
        description: "Failed to copy link",
      });
    }
  };

  const shareViaEmail = () => {
    const subject = encodeURIComponent(event.title);
    const body = encodeURIComponent(
      `Check out this event: ${event.title}\n\n${event.description}\n\nDate: ${new Date(event.startDate).toLocaleDateString()}\nLocation: ${event.location.venue}, ${event.location.address}\n\nView event details: ${eventUrl}`
    );
    window.open(`mailto:?subject=${subject}&body=${body}`);
  };

  const shareToSocialMedia = (platform: 'twitter' | 'facebook' | 'linkedin') => {
    const text = encodeURIComponent(`Check out this event: ${event.title}`);
    const url = encodeURIComponent(eventUrl);
    
    const links = {
      twitter: `https://twitter.com/intent/tweet?text=${text}&url=${url}`,
      facebook: `https://www.facebook.com/sharer/sharer.php?u=${url}`,
      linkedin: `https://www.linkedin.com/sharing/share-offsite/?url=${url}`
    };

    window.open(links[platform], '_blank', 'width=600,height=400');
  };

  const sendInvites = async () => {
    const emails = inviteEmails.split(',').map(email => email.trim()).filter(Boolean);
    
    if (emails.length === 0) {
      toast({
        variant: "destructive",
        description: "Please enter at least one email address",
      });
      return;
    }

    try {
      const response = await fetch(`/api/events/${event.id}/invite`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          emails,
          message: inviteMessage,
        }),
      });

      if (!response.ok) throw new Error('Failed to send invites');

      toast({
        description: "Invitations sent successfully",
      });
      
      // Clear the form
      setInviteEmails("");
      setInviteMessage("");
    } catch (error) {
      console.error('Error sending invites:', error);
      toast({
        variant: "destructive",
        description: "Failed to send invitations",
      });
    }
  };

  return (
    <Tabs defaultValue="share" className="w-full">
      <TabsList className="grid w-full grid-cols-2">
        <TabsTrigger value="share">Share</TabsTrigger>
        <TabsTrigger value="invite">Invite</TabsTrigger>
      </TabsList>

      <TabsContent value="share" className="space-y-4">
        <Card>
          <CardHeader>
            <CardTitle>Share Link</CardTitle>
            <CardDescription>
              Copy the event link or share directly to social media
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex space-x-2">
              <Input
                value={eventUrl}
                readOnly
                className="flex-1"
              />
              <Button 
                variant="outline" 
                size="icon"
                onClick={copyToClipboard}
              >
                {copied ? (
                  <Check className="h-4 w-4 text-green-500" />
                ) : (
                  <Copy className="h-4 w-4" />
                )}
              </Button>
            </div>
            
            <Separator className="my-4" />
            
            <div className="flex justify-between">
              <Button
                variant="outline"
                size="lg"
                className="flex-1 mx-1"
                onClick={() => shareToSocialMedia('twitter')}
              >
                <Twitter className="h-5 w-5 mr-2" />
                Twitter
              </Button>
              <Button
                variant="outline"
                size="lg"
                className="flex-1 mx-1"
                onClick={() => shareToSocialMedia('facebook')}
              >
                <Facebook className="h-5 w-5 mr-2" />
                Facebook
              </Button>
              <Button
                variant="outline"
                size="lg"
                className="flex-1 mx-1"
                onClick={() => shareToSocialMedia('linkedin')}
              >
                <Linkedin className="h-5 w-5 mr-2" />
                LinkedIn
              </Button>
              <Button
                variant="outline"
                size="lg"
                className="flex-1 mx-1"
                onClick={shareViaEmail}
              >
                <Mail className="h-5 w-5 mr-2" />
                Email
              </Button>
            </div>
          </CardContent>
        </Card>
      </TabsContent>

      <TabsContent value="invite" className="space-y-4">
        <Card>
          <CardHeader>
            <CardTitle>Invite People</CardTitle>
            <CardDescription>
              Send email invitations to your guests
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <label className="text-sm font-medium">
                Email Addresses
              </label>
              <Input
                placeholder="Enter email addresses (comma-separated)"
                value={inviteEmails}
                onChange={(e) => setInviteEmails(e.target.value)}
              />
              <p className="text-sm text-muted-foreground">
                Separate multiple email addresses with commas
              </p>
            </div>
            
            <div className="space-y-2">
              <label className="text-sm font-medium">
                Personal Message (Optional)
              </label>
              <Textarea
                placeholder="Add a personal message to your invitation"
                value={inviteMessage}
                onChange={(e) => setInviteMessage(e.target.value)}
                className="h-32"
              />
            </div>
          </CardContent>
          <CardFooter>
            <Button 
              className="w-full"
              onClick={sendInvites}
            >
              <Mail className="h-4 w-4 mr-2" />
              Send Invitations
            </Button>
          </CardFooter>
        </Card>
      </TabsContent>
    </Tabs>
  );
}

================
File: src/components/events/venue-map.tsx
================
"use client";

import { useEffect, useState } from "react";
import { GoogleMap, Marker, LoadScript } from "@react-google-maps/api";

interface VenueMapProps {
  address: string;
  venue: string;
  onLocationSelected?: (location: { lat: number; lng: number }) => void;
  initialLocation?: { lat: number; lng: number };
  isEditable?: boolean;
}

export function VenueMap({
  address,
  venue,
  onLocationSelected,
  initialLocation,
  isEditable = false,
}: VenueMapProps) {
  const [location, setLocation] = useState(initialLocation);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!initialLocation && address) {
      geocodeAddress();
    }
  }, [address]);

  const geocodeAddress = async () => {
    try {
      const response = await fetch(
        `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(
          address
        )}&key=${process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY}`
      );
      const data = await response.json();
      if (data.results[0]) {
        const { lat, lng } = data.results[0].geometry.location;
        setLocation({ lat, lng });
        if (onLocationSelected) {
          onLocationSelected({ lat, lng });
        }
      }
    } catch (error) {
      console.error("Error geocoding address:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleMapClick = (e: google.maps.MapMouseEvent) => {
    if (isEditable && onLocationSelected) {
      const lat = e.latLng?.lat();
      const lng = e.latLng?.lng();
      if (lat && lng) {
        setLocation({ lat, lng });
        onLocationSelected({ lat, lng });
      }
    }
  };

  if (loading || !location) return <div>Loading map...</div>;

  return (
    <LoadScript googleMapsApiKey={process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY!}>
      <GoogleMap
        mapContainerStyle={{ width: "100%", height: "400px" }}
        center={location}
        zoom={15}
        onClick={handleMapClick}
      >
        <Marker
          position={location}
          title={venue}
          draggable={isEditable}
          onDragEnd={(e) => {
            if (onLocationSelected && e.latLng) {
              const newLoc = {
                lat: e.latLng.lat(),
                lng: e.latLng.lng(),
              };
              setLocation(newLoc);
              onLocationSelected(newLoc);
            }
          }}
        />
      </GoogleMap>
    </LoadScript>
  );
}

================
File: src/components/export/export-button.tsx
================
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Download, FileSpreadsheet, Files } from "lucide-react";
import { exportToExcel, exportToCSV } from "@/lib/export";

interface ExportButtonProps {
  data: any[];
  filename: string;
  type: "guests" | "events" | "analytics";
}

export function ExportButton({ data, filename, type }: ExportButtonProps) {
  const [loading, setLoading] = useState(false);

  const handleExport = async (format: "excel" | "csv") => {
    setLoading(true);
    try {
      if (format === "excel") {
        const columns = getColumnsForType(type);
        await exportToExcel(data, filename, [{ name: "Data", columns }]);
      } else {
        exportToCSV(data, filename);
      }
    } catch (error) {
      console.error("Export failed:", error);
    } finally {
      setLoading(false);
    }
  };

  const getColumnsForType = (type: string) => {
    const columnMappings = {
      guests: [
        { header: "Name", key: "name", width: 20 },
        { header: "Email", key: "email", width: 30 },
        { header: "Status", key: "status", width: 15 },
        { header: "Role", key: "role", width: 15 },
        { header: "Invited At", key: "invitedAt", width: 20 },
        { header: "Checked In", key: "checkedIn", width: 15 },
      ],
      events: [
        { header: "Title", key: "title", width: 30 },
        { header: "Date", key: "startDate", width: 20 },
        { header: "Location", key: "location.venue", width: 25 },
        { header: "Status", key: "status", width: 15 },
        { header: "Capacity", key: "capacity", width: 15 },
      ],
      analytics: [
        { header: "Metric", key: "metric", width: 25 },
        { header: "Value", key: "value", width: 20 },
        { header: "Date", key: "date", width: 20 },
      ],
    };

    return columnMappings[type as keyof typeof columnMappings] || [];
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" disabled={loading}>
          <Download className="mr-2 h-4 w-4" />
          Export
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuLabel>Choose Format</DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem onClick={() => handleExport("excel")}>
          <FileSpreadsheet className="mr-2 h-4 w-4" />
          Export to Excel
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => handleExport("csv")}>
          <Files className="mr-2 h-4 w-4" />
          Export to CSV
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

================
File: src/components/filters/advanced-filter.tsx
================
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { DatePicker } from "@/components/ui/date-picker";
import { Filter, SortAsc, SortDesc } from "lucide-react";

interface FilterConfig {
  field: string;
  operator: string;
  value: any;
}

interface SortConfig {
  field: string;
  direction: "asc" | "desc";
}

interface AdvancedFilterProps {
  onFilterChange: (filters: FilterConfig[]) => void;
  onSortChange: (sort: SortConfig[]) => void;
  fields: {
    name: string;
    type: "text" | "number" | "date" | "boolean" | "select";
    options?: string[];
  }[];
}

export function AdvancedFilter({
  onFilterChange,
  onSortChange,
  fields,
}: AdvancedFilterProps) {
  const [filters, setFilters] = useState<FilterConfig[]>([]);
  const [sorts, setSorts] = useState<SortConfig[]>([]);

  const addFilter = () => {
    const newFilter = {
      field: fields[0].name,
      operator: "equals",
      value: "",
    };
    setFilters([...filters, newFilter]);
  };

  const updateFilter = (index: number, updates: Partial<FilterConfig>) => {
    const newFilters = filters.map((filter, i) =>
      i === index ? { ...filter, ...updates } : filter
    );
    setFilters(newFilters);
    onFilterChange(newFilters);
  };

  const removeFilter = (index: number) => {
    const newFilters = filters.filter((_, i) => i !== index);
    setFilters(newFilters);
    onFilterChange(newFilters);
  };

  const addSort = () => {
    const newSort = {
      field: fields[0].name,
      direction: "asc" as const,
    };
    setSorts([...sorts, newSort]);
  };

  const updateSort = (index: number, updates: Partial<SortConfig>) => {
    const newSorts = sorts.map((sort, i) =>
      i === index ? { ...sort, ...updates } : sort
    );
    setSorts(newSorts);
    onSortChange(newSorts);
  };

  const removeSort = (index: number) => {
    const newSorts = sorts.filter((_, i) => i !== index);
    setSorts(newSorts);
    onSortChange(newSorts);
  };

  return (
    <Sheet>
      <SheetTrigger asChild>
        <Button variant="outline">
          <Filter className="mr-2 h-4 w-4" />
          Advanced Filters
        </Button>
      </SheetTrigger>
      <SheetContent className="w-[400px]">
        <SheetHeader>
          <SheetTitle>Advanced Filters</SheetTitle>
          <SheetDescription>
            Configure filters and sorting options
          </SheetDescription>
        </SheetHeader>

        <div className="py-4 space-y-4">
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <h3 className="font-medium">Filters</h3>
              <Button onClick={addFilter} variant="outline" size="sm">
                Add Filter
              </Button>
            </div>
            {filters.map((filter, index) => (
              <div key={index} className="space-y-2 p-2 border rounded-md">
                <Select
                  value={filter.field}
                  onValueChange={(value) =>
                    updateFilter(index, { field: value })
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select field" />
                  </SelectTrigger>
                  <SelectContent>
                    {fields.map((field) => (
                      <SelectItem key={field.name} value={field.name}>
                        {field.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>

                <Select
                  value={filter.operator}
                  onValueChange={(value) =>
                    updateFilter(index, { operator: value })
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select operator" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="equals">Equals</SelectItem>
                    <SelectItem value="contains">Contains</SelectItem>
                    <SelectItem value="greaterThan">Greater Than</SelectItem>
                    <SelectItem value="lessThan">Less Than</SelectItem>
                  </SelectContent>
                </Select>

                <Input
                  placeholder="Value"
                  value={filter.value}
                  onChange={(e) =>
                    updateFilter(index, { value: e.target.value })
                  }
                />

                <Button
                  variant="destructive"
                  size="sm"
                  onClick={() => removeFilter(index)}
                >
                  Remove
                </Button>
              </div>
            ))}
          </div>

          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <h3 className="font-medium">Sorting</h3>
              <Button onClick={addSort} variant="outline" size="sm">
                Add Sort
              </Button>
            </div>
            {sorts.map((sort, index) => (
              <div key={index} className="space-y-2 p-2 border rounded-md">
                <Select
                  value={sort.field}
                  onValueChange={(value) =>
                    updateSort(index, { field: value })
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select field" />
                  </SelectTrigger>
                  <SelectContent>
                    {fields.map((field) => (
                      <SelectItem key={field.name} value={field.name}>
                        {field.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>

                <div className="flex items-center space-x-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() =>
                      updateSort(index, {
                        direction: sort.direction === "asc" ? "desc" : "asc",
                      })
                    }
                  >
                    {sort.direction === "asc" ? (
                      <SortAsc className="h-4 w-4" />
                    ) : (
                      <SortDesc className="h-4 w-4" />
                    )}
                  </Button>
                  <Button
                    variant="destructive"
                    size="sm"
                    onClick={() => removeSort(index)}
                  >
                    Remove
                  </Button>
                </div>
              </div>
            ))}
          </div>
        </div>

        <div className="mt-4">
          <Button
            className="w-full"
            onClick={() => {
              onFilterChange(filters);
              onSortChange(sorts);
            }}
          >
            Apply Filters & Sorting
          </Button>
        </div>
      </SheetContent>
    </Sheet>
  );
}

================
File: src/components/layout/event-card.tsx
================
import {
    Card,
    CardContent,
    CardDescription,
    CardFooter,
    CardHeader,
    CardTitle,
  } from "@/components/ui/card";
  import { Badge } from "@/components/ui/badge";
  import { Button } from "@/components/ui/button";
  import { Calendar, Clock, MapPin, Users } from "lucide-react";
  import { format } from "date-fns";
  
  interface EventCardProps {
    event: {
      title: string;
      description: string;
      startDate: Date;
      endDate: Date;
      location: {
        venue: string;
      };
      capacity: number;
      status: string;
    };
  }
  
  export function EventCard({ event }: EventCardProps) {
    return (
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle className="line-clamp-1">{event.title}</CardTitle>
            <Badge variant={event.status === "published" ? "default" : "secondary"}>
              {event.status}
            </Badge>
          </div>
          <CardDescription className="line-clamp-2">
            {event.description}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-2">
          <div className="flex items-center space-x-2 text-sm">
            <Calendar className="h-4 w-4" />
            <span>{format(new Date(event.startDate), "PPP")}</span>
          </div>
          <div className="flex items-center space-x-2 text-sm">
            <Clock className="h-4 w-4" />
            <span>{format(new Date(event.startDate), "p")}</span>
          </div>
          <div className="flex items-center space-x-2 text-sm">
            <MapPin className="h-4 w-4" />
            <span>{event.location.venue}</span>
          </div>
          <div className="flex items-center space-x-2 text-sm">
            <Users className="h-4 w-4" />
            <span>{event.capacity} attendees</span>
          </div>
        </CardContent>
        <CardFooter className="flex justify-between">
          <Button variant="outline">Edit</Button>
          <Button>View Details</Button>
        </CardFooter>
      </Card>
    );
  }

================
File: src/components/layout/main-nav.tsx
================
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";

export function MainNav() {
  const pathname = usePathname();

  const routes = [
    {
      href: "/dashboard",
      label: "Dashboard",
      active: pathname === "/dashboard",
    },
    {
      href: "/events",
      label: "Events",
      active: pathname === "/events",
    },
    {
      href: "/calendar",
      label: "Calendar",
      active: pathname === "/calendar",
    },
  ];

  return (
    <nav className="flex items-center space-x-4 lg:space-x-6">
      {routes.map((route) => (
        <Link
          key={route.href}
          href={route.href}
          className={cn(
            "text-sm font-medium transition-colors hover:text-primary",
            route.active ? "text-primary" : "text-muted-foreground"
          )}
        >
          {route.label}
        </Link>
      ))}
    </nav>
  );
}

================
File: src/components/layout/navbar.tsx
================
import { UserButton } from "@clerk/nextjs";
import { ModeToggle } from "../../components/mode-toggle";
import { MainNav } from "../../components/layout/main-nav";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Plus } from "lucide-react";

export function Navbar() {
  return (
    <div className="border-b">
      <div className="flex h-16 items-center px-4">
        <div className="flex items-center space-x-4">
          <Link href="/" className="font-bold">
            Feest
          </Link>
          <MainNav />
        </div>
        <div className="ml-auto flex items-center space-x-4">
          <Button asChild variant="outline" size="sm">
            <Link href="/events/new">
              <Plus className="mr-2 h-4 w-4" />
              Create Event
            </Link>
          </Button>
          <ModeToggle />
          <UserButton />
        </div>
      </div>
    </div>
  );
}

================
File: src/components/providers/theme-provider.tsx
================
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import { type ThemeProviderProps } from "next-themes/dist/types"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

================
File: src/components/subscription/feature-gate.tsx
================
"use client";

import { ReactNode, createElement } from "react";
import { Feature } from "@/types/subscription";
import { useFeatureAccess } from "@/hooks/use-feature-access";
import { Button } from "@/components/ui/button";
import { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";

interface FeatureGateProps {
  feature: Feature;
  children: ReactNode;
  fallback?: ReactNode;
  loadingComponent?: ReactNode;
}

export function FeatureGate({ 
  feature, 
  children, 
  fallback,
  loadingComponent 
}: FeatureGateProps): JSX.Element | null {
  const { checkFeature, isLoading } = useFeatureAccess();
  const [showUpgradeDialog, setShowUpgradeDialog] = useState(false);

  if (isLoading) {
    return loadingComponent ? 
      createElement('div', null, loadingComponent) : 
      null;
  }

  const hasAccess = checkFeature(feature);

  if (hasAccess) {
    return createElement('div', null, children);
  }

  if (fallback) {
    return createElement('div', null, fallback);
  }

  return createElement('div', null,
    <div className="space-y-2 p-4 border rounded-md bg-muted/5">
      <p className="text-sm text-muted-foreground">
        This feature requires an upgrade
      </p>
      <Button 
        variant="outline" 
        size="sm" 
        onClick={() => setShowUpgradeDialog(true)}
      >
        Upgrade Plan
      </Button>

      <Dialog open={showUpgradeDialog} onOpenChange={setShowUpgradeDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Upgrade Your Plan</DialogTitle>
            <DialogDescription>
              This feature is available in our Pro and Business plans.
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-4 pt-4">
            <Button
              className="w-full"
              onClick={() => window.location.href = '/settings/subscription'}
            >
              View Plans
            </Button>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}

================
File: src/components/subscription/pricing-table.tsx
================
"use client";

import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { SUBSCRIPTION_PLANS, SubscriptionTier } from "@/types/subscription";
import { Check } from "lucide-react";

interface PricingTableProps {
  currentPlan?: string;
  onSubscribe: (planId: SubscriptionTier) => Promise<void>;
  isLoading: boolean;
}

export function PricingTable({ 
  currentPlan, 
  onSubscribe, 
  isLoading 
}: PricingTableProps) {
  return (
    <div className="grid gap-6 md:grid-cols-3">
      {Object.entries(SUBSCRIPTION_PLANS).map(([key, plan]) => {
        const isCurrentPlan = currentPlan === key;
        
        return (
          <Card key={key} className="p-6 space-y-4">
            <div className="space-y-2">
              <h3 className="text-xl font-bold">{plan.name}</h3>
              <p className="text-muted-foreground">{plan.description}</p>
            </div>
            
            <div className="text-3xl font-bold">
              ${plan.price}
              <span className="text-sm font-normal text-muted-foreground">
                /month
              </span>
            </div>

            <ul className="space-y-2">
              {plan.features.map((feature, i) => (
                <li key={i} className="flex items-center">
                  <Check className="h-4 w-4 mr-2 text-primary" />
                  {feature}
                </li>
              ))}
            </ul>

            <Button
              className="w-full"
              disabled={isLoading || isCurrentPlan}
              onClick={() => onSubscribe(key as SubscriptionTier)}
            >
              {isLoading
                ? "Loading..."
                : isCurrentPlan
                ? "Current Plan"
                : "Subscribe"}
            </Button>
          </Card>
        );
      })}
    </div>
  );
}

================
File: src/components/subscription/subscribe-button.tsx
================
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';
import { loadStripe } from '@stripe/stripe-js';

interface SubscribeButtonProps {
  planId: string;
  priceId: string;
}

export function SubscribeButton({ planId, priceId }: SubscribeButtonProps) {
  const [loading, setLoading] = useState(false);
  const { toast } = useToast();

  const handleSubscribe = async () => {
    try {
      setLoading(true);

      // 1. Create checkout session
      const response = await fetch('/api/subscriptions/create-checkout', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ planId, priceId }),
      });

      if (!response.ok) throw new Error('Failed to create checkout session');
      const { sessionId } = await response.json();

      // 2. Load Stripe and redirect to checkout
      const stripe = await loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!);
      if (!stripe) throw new Error('Failed to load Stripe');

      const { error } = await stripe.redirectToCheckout({ sessionId });
      if (error) throw error;

    } catch (error) {
      console.error('Subscription error:', error);
      toast({
        title: 'Error',
        description: 'Failed to process subscription. Please try again.',
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <Button 
      onClick={handleSubscribe} 
      disabled={loading}
      className="w-full"
    >
      {loading ? 'Processing...' : 'Subscribe'}
    </Button>
  );
}

================
File: src/components/subscription/subscription-content.tsx
================
// src/components/subscription/subscription-content.tsx
"use client";

import { useRouter } from "next/navigation";
import { useState } from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { PricingTable } from "./pricing-table";
import { useToast } from "@/hooks/use-toast";
import { SubscriptionTier } from "@/types/subscription";

interface SubscriptionContentProps {
  currentPlan?: string;
}

export function SubscriptionContent({ currentPlan }: SubscriptionContentProps) {
  const router = useRouter();
  const { toast } = useToast();
  const [isLoading, setIsLoading] = useState(false);  

  const handleSubscribe = async (planId: SubscriptionTier) => {
    try {
      setIsLoading(true);
      const response = await fetch("/api/subscriptions/create-checkout", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ planId }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || "Failed to create checkout session");
      }

      // Redirect to Stripe Checkout
      if (data.url) {
        router.push(data.url);
      }
    } catch (error: any) {
      console.error("Subscription error:", error);
      toast({
        title: "Error",
        description: error.message || "Failed to process subscription",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="container max-w-6xl py-8 space-y-8">
      <div className="space-y-2">
        <h1 className="text-3xl font-bold">Subscription Plans</h1>
        <p className="text-muted-foreground">
          Choose the perfect plan for your needs
        </p>
      </div>

      <PricingTable
        currentPlan={currentPlan}
        onSubscribe={handleSubscribe}
        isLoading={isLoading}
      />
    </div>
  );
}

================
File: src/components/subscription/subscription-plans.tsx
================
"use client";

import { useState } from "react";
import { loadStripe } from "@stripe/stripe-js";
import { useRouter } from "next/navigation";
import { SUBSCRIPTION_PLANS, SubscriptionPlan, SubscriptionTier } from "@/types/subscription";
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Icons } from "@/components/ui/icons";
import { useToast } from "@/hooks/use-toast";
import { formatDate } from "@/lib/utils";

interface Subscription {
  planId: SubscriptionTier;
  status: 'active' | 'past_due' | 'canceled' | 'inactive';
  currentPeriodEnd: string;
}

interface SubscriptionPlansProps {
  currentSubscription: Subscription | null;
}

export function SubscriptionPlans({ currentSubscription }: SubscriptionPlansProps) {
  const [loading, setLoading] = useState<string | null>(null);
  const { toast } = useToast();
  const router = useRouter();

  const handleSubscribe = async (planId: SubscriptionTier) => {
    try {
      setLoading(planId);

      const response = await fetch("/api/subscriptions/checkout", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ planId }),
      });

      if (!response.ok) {
        throw new Error("Failed to create checkout session");
      }

      const data = await response.json();

      const stripe = await loadStripe(process.env.NEXT_PUBLIC_STRIPE_KEY!);
      if (!stripe) throw new Error("Stripe failed to load");

      const { error } = await stripe.redirectToCheckout({
        sessionId: data.sessionId,
      });

      if (error) {
        throw error;
      }
    } catch (error) {
      console.error(error);
      toast({
        title: "Error",
        description: "Failed to process subscription. Please try again.",
        variant: "destructive",
      });
    } finally {
      setLoading(null);
    }
  };

  const handleManageBilling = async () => {
    try {
      setLoading("manage");
      const response = await fetch("/api/subscriptions/portal", {
        method: "POST",
      });
      const data = await response.json();
      router.push(data.url);
    } catch (error) {
      console.error(error);
      toast({
        title: "Error",
        description: "Failed to open billing portal. Please try again.",
        variant: "destructive",
      });
    } finally {
      setLoading(null);
    }
  };

  return (
    <div className="space-y-8">
      {currentSubscription && (
        <div className="rounded-lg border p-4">
          <h2 className="font-semibold mb-2">Current Subscription</h2>
          <div className="space-y-2">
            <p>
              Plan:{" "}
              <span className="font-medium">
                {SUBSCRIPTION_PLANS[currentSubscription.planId].name}
              </span>
            </p>
            <p>
              Status:{" "}
              <span 
                className={
                  currentSubscription.status === "active"
                    ? "text-green-600"
                    : "text-yellow-600"
                }
              >
                {currentSubscription.status}
              </span>
            </p>
            <p>
              Current Period Ends:{" "}
              {formatDate(new Date(currentSubscription.currentPeriodEnd))}
            </p>
            <Button
              variant="outline"
              onClick={handleManageBilling}
              disabled={loading === "manage"}
            >
              {loading === "manage" && (
                <Icons.spinner className="mr-2 h-4 w-4 animate-spin" />
              )}
              Manage Billing
            </Button>
          </div>
        </div>
      )}

      <div className="grid gap-6 lg:grid-cols-3">
        {(Object.entries(SUBSCRIPTION_PLANS) as [SubscriptionTier, SubscriptionPlan][]).map(([id, plan]) => (
          <Card 
            key={id}
            className={
              currentSubscription?.planId === id 
                ? "border-primary"
                : undefined
            }
          >
            <CardHeader>
              <CardTitle>
                {plan.name}
                {currentSubscription?.planId === id && (
                  <span className="ml-2 text-sm text-primary">Current Plan</span>
                )}
              </CardTitle>
              <div className="text-2xl font-bold">
                ${plan.price}
                <span className="text-sm font-normal text-muted-foreground">
                  /month
                </span>
              </div>
            </CardHeader>
            <CardContent>
              <ul className="space-y-2 text-sm">
                <li className="flex items-center">
                  <Icons.check className="mr-2 h-4 w-4 text-primary" />
                  {plan.limits.eventsPerMonth === -1
                    ? "Unlimited events"
                    : `${plan.limits.eventsPerMonth} events per month`}
                </li>
                <li className="flex items-center">
                  <Icons.check className="mr-2 h-4 w-4 text-primary" />
                  {plan.limits.guestsPerEvent} guests per event
                </li>
                {plan.limits.features.map((feature) => (
                  <li key={feature} className="flex items-center">
                    <Icons.check className="mr-2 h-4 w-4 text-primary" />
                    {feature
                      .split("_")
                      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
                      .join(" ")}
                  </li>
                ))}
              </ul>
            </CardContent>
            <CardFooter>
              <Button
                className="w-full"
                variant={
                  currentSubscription?.planId === id ? "outline" : "default"
                }
                disabled={
                  loading !== null ||
                  currentSubscription?.planId === id ||
                  (currentSubscription?.status === "past_due" && plan.price > 0)
                }
                onClick={() => handleSubscribe(id)}
              >
                {loading === id && (
                  <Icons.spinner className="mr-2 h-4 w-4 animate-spin" />
                )}
                {currentSubscription?.planId === id
                  ? "Current Plan"
                  : "Subscribe"}
              </Button>
            </CardFooter>
          </Card>
        ))}
      </div>
    </div>
  );
}

================
File: src/components/subscription/SubscriptionProvider.tsx
================
'use client';

import { createContext, useContext, useEffect, useState } from 'react';
import { useAuth } from '@clerk/nextjs';
import { SubscriptionPlan } from '@/types/subscription';

interface SubscriptionContextType {
  subscription: SubscriptionPlan | null;
  isLoading: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
}

const SubscriptionContext = createContext<SubscriptionContextType>({
  subscription: null,
  isLoading: true,
  error: null,
  refresh: async () => {},
});

export function SubscriptionProvider({ children }: { children: React.ReactNode }) {
  const { userId, isLoaded: isAuthLoaded } = useAuth();
  const [subscription, setSubscription] = useState<SubscriptionPlan | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchSubscription = async () => {
    if (!userId) {
      setIsLoading(false);
      return;
    }

    try {
      setIsLoading(true);
      setError(null);
      const response = await fetch('/api/subscriptions');
      if (!response.ok) throw new Error('Failed to fetch subscription');
      const data = await response.json();
      setSubscription(data);
    } catch (error) {
      setError(error instanceof Error ? error : new Error('Unknown error'));
      console.error('Error fetching subscription:', error);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    if (isAuthLoaded && userId) {
      fetchSubscription();
    }
  }, [userId, isAuthLoaded]);

  if (!isAuthLoaded) return null;

  return (
    <SubscriptionContext.Provider 
      value={{ 
        subscription, 
        isLoading, 
        error, 
        refresh: fetchSubscription 
      }}
    >
      {children}
    </SubscriptionContext.Provider>
  );
}

export const useSubscription = () => useContext(SubscriptionContext);

================
File: src/components/ui/a11y-announcer.tsx
================
'use client';

import { useEffect, useState } from 'react';

export function A11yAnnouncer() {
  const [announcement, setAnnouncement] = useState('');

  useEffect(() => {
    const handleRouteChange = () => {
      const pageTitle = document.title;
      setAnnouncement(`Navigated to ${pageTitle}`);
    };

    // Listen for route changes
    window.addEventListener('routeChangeComplete', handleRouteChange);
    return () => window.removeEventListener('routeChangeComplete', handleRouteChange);
  }, []);

  return (
    <div
      role="status"
      aria-live="polite"
      aria-atomic="true"
      className="sr-only"
    >
      {announcement}
    </div>
  );
}

================
File: src/components/ui/avatar.tsx
================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

================
File: src/components/ui/badge.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

================
File: src/components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: src/components/ui/calendar.tsx
================
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ...props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ...props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }

================
File: src/components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: src/components/ui/date-picker.tsx
================
"use client"

import * as React from "react"
import { format } from "date-fns"
import { Calendar as CalendarIcon } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Calendar } from "@/components/ui/calendar"
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover"

export function DatePicker() {
  const [date, setDate] = React.useState<Date>()

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button
          variant={"outline"}
          className={cn(
            "w-[280px] justify-start text-left font-normal",
            !date && "text-muted-foreground"
          )}
        >
          <CalendarIcon className="mr-2 h-4 w-4" />
          {date ? format(date, "PPP") : <span>Pick a date</span>}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-auto p-0">
        <Calendar
          mode="single"
          selected={date}
          onSelect={setDate}
          initialFocus
        />
      </PopoverContent>
    </Popover>
  )
}

================
File: src/components/ui/dialog.tsx
================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

================
File: src/components/ui/dropdown-menu.tsx
================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

================
File: src/components/ui/form.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

================
File: src/components/ui/icons.tsx
================
import {
    AlertTriangle,
    ArrowRight,
    Check,
    ChevronLeft,
    ChevronRight,
    CreditCard,
    File,
    FileText,
    HelpCircle,
    Image,
    Laptop,
    Loader2,
    LucideProps,
    Moon,
    MoreVertical,
    Pizza,
    Plus,
    Settings,
    SunMedium,
    Trash,
    Twitter,
    User,
    X,
    Calendar,
    Clock,
    MapPin,
    Users,
    Share2,
    Download,
    Mail,
    MessageCircle,
    Search,
    Filter,
    Bell,
    CheckCircle,
    Ticket,
    BarChart,
    RefreshCcw,
    Heart,
    type LucideIcon,
  } from "lucide-react"
  
  export type Icon = LucideIcon
  
  export const Icons = {
    logo: ({ ...props }: LucideProps) => (
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        strokeWidth="1.5"
        stroke="currentColor"
        fill="none"
        strokeLinecap="round"
        strokeLinejoin="round"
        {...props}
      >
        <path stroke="none" d="M0 0h24v24H0z" fill="none" />
        <circle cx="12" cy="12" r="9" />
        <line x1="12" y1="8" x2="12.01" y2="8" />
        <polyline points="11 12 12 12 12 16 13 16" />
      </svg>
    ),
    close: X,
    spinner: Loader2,
    chevronLeft: ChevronLeft,
    chevronRight: ChevronRight,
    trash: Trash,
    settings: Settings,
    user: User,
    arrowRight: ArrowRight,
    help: HelpCircle,
    pizza: Pizza,
    sun: SunMedium,
    moon: Moon,
    laptop: Laptop,
    calendar: Calendar,
    clock: Clock,
    mapPin: MapPin,
    users: Users,
    share: Share2,
    download: Download,
    mail: Mail,
    message: MessageCircle,
    search: Search,
    filter: Filter,
    bell: Bell,
    check: Check,
    checkCircle: CheckCircle,
    ticket: Ticket,
    chart: BarChart,
    refresh: RefreshCcw,
    heart: Heart,
    plus: Plus,
    image: Image,
    file: File,
    fileText: FileText,
    moreVertical: MoreVertical,
    creditCard: CreditCard,
    twitter: Twitter,
    warning: AlertTriangle,
    google: ({ ...props }: LucideProps) => (
      <svg role="img" viewBox="0 0 24 24" {...props}>
        <path
          fill="currentColor"
          d="M12.48 10.92v3.28h7.84c-.24 1.84-.853 3.187-1.787 4.133-1.147 1.147-2.933 2.4-6.053 2.4-4.827 0-8.6-3.893-8.6-8.72s3.773-8.72 8.6-8.72c2.6 0 4.507 1.027 5.907 2.347l2.307-2.307C18.747 1.44 16.133 0 12.48 0 5.867 0 .307 5.387.307 12s5.56 12 12.173 12c3.573 0 6.267-1.173 8.373-3.36 2.16-2.16 2.84-5.213 2.84-7.667 0-.76-.053-1.467-.173-2.053H12.48z"
        />
      </svg>
    ),
    // Payment Provider Icons
    stripe: ({ ...props }: LucideProps) => (
      <svg role="img" viewBox="0 0 24 24" {...props}>
        <path
          fill="currentColor"
          d="M13.976 9.15c-2.172-.806-3.356-1.426-3.356-2.409 0-.831.683-1.305 1.901-1.305 2.227 0 4.515.858 6.09 1.631l.89-5.494C18.252.975 15.697 0 12.165 0 9.667 0 7.589.654 6.104 1.872 4.56 3.147 3.757 4.992 3.757 7.218c0 4.039 2.467 5.76 6.476 7.219 2.585.92 3.445 1.574 3.445 2.583 0 .98-.84 1.545-2.354 1.545-1.875 0-4.965-.921-6.99-2.109l-.9 5.555C5.175 22.99 8.385 24 11.714 24c2.641 0 4.843-.624 6.328-1.813 1.664-1.305 2.525-3.236 2.525-5.732 0-4.128-2.524-5.851-6.591-7.305h.002z"
        />
      </svg>
    ),
    paypal: ({ ...props }: LucideProps) => (
      <svg role="img" viewBox="0 0 24 24" {...props}>
        <path
          fill="currentColor"
          d="M7.076 21.337H2.47a.641.641 0 0 1-.633-.74L4.944.901C5.026.382 5.474 0 5.998 0h7.46c2.57 0 4.578.543 5.987 1.62 1.407 1.075 2.115 2.651 2.115 4.719 0 .975-.169 1.891-.51 2.741-.339.85-.83 1.591-1.465 2.221-.636.63-1.39 1.14-2.255 1.528-.866.389-1.821.656-2.86.805l-.102.023c.296.373.466.851.466 1.368 0 .298-.065.58-.189.841l-1.596 3.821c-.187.45-.623.741-1.104.741h-4.037c-.481 0-.917-.291-1.103-.74l-1.363-3.265a1.237 1.237 0 0 1-.155-.606c0-.517.171-.995.466-1.368l-.101-.024c-1.04-.148-1.994-.415-2.86-.804-.866-.388-1.62-.898-2.255-1.528-.636-.63-1.127-1.371-1.466-2.221-.34-.85-.51-1.766-.51-2.741 0-2.068.708-3.644 2.115-4.719C4.168.543 6.177 0 8.747 0h7.46c.524 0 .972.382 1.054.901l3.108 19.696a.641.641 0 0 1-.633.74h-4.61c-.455 0-.868-.274-1.042-.696l-.459-1.114a1.208 1.208 0 0 1-.189-.69c0-.517.171-.995.466-1.368l-.101-.024c-1.04-.148-1.994-.415-2.86-.804-.866-.388-1.62-.898-2.255-1.528-.636-.63-1.127-1.371-1.466-2.221-.34-.85-.51-1.766-.51-2.741 0-2.068.708-3.644 2.115-4.719C10.588.543 12.597 0 15.167 0h7.46c.524 0 .972.382 1.054.901l3.108 19.696a.641.641 0 0 1-.633.74h-4.61c-.455 0-.868-.274-1.042-.696l-.459-1.114a1.208 1.208 0 0 1-.189-.69c0-.517.171-.995.466-1.368l-.101-.024c-1.04-.148-1.994-.415-2.86-.804-.866-.388-1.62-.898-2.255-1.528-.636-.63-1.127-1.371-1.466-2.221-.34-.85-.51-1.766-.51-2.741 0-2.068.708-3.644 2.115-4.719C16.928.543 18.937 0 21.507 0H24l-3.893 24H7.076z"
        />
      </svg>
    ),
    // Social Icons
    facebook: ({ ...props }: LucideProps) => (
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" {...props}>
        <path
          fill="currentColor"
          d="M279.14 288l14.22-92.66h-88.91v-60.13c0-25.35 12.42-50.06 52.24-50.06h40.42V6.26S260.43 0 225.36 0c-73.22 0-121.08 44.38-121.08 124.72v70.62H22.89V288h81.39v224h100.17V288z"
        />
      </svg>
    ),
    instagram: ({ ...props }: LucideProps) => (
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" {...props}>
        <path
          fill="currentColor"
          d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"
        />
      </svg>
    ),
    linkedin: ({ ...props }: LucideProps) => (
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" {...props}>
        <path
          fill="currentColor"
          d="M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z"
        />
      </svg>
    )
}
  
export type IconKey = keyof typeof Icons
  
export type { LucideProps }

================
File: src/components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

================
File: src/components/ui/label.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

================
File: src/components/ui/loading-state.tsx
================
import { Loader2 } from "lucide-react";

export function LoadingSpinner() {
  return (
    <div className="flex h-full w-full items-center justify-center" role="status">
      <Loader2 className="h-8 w-8 animate-spin text-primary" />
      <span className="sr-only">Loading...</span>
    </div>
  );
}

================
File: src/components/ui/popover.tsx
================
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }

================
File: src/components/ui/progress.tsx
================
"use client";

import * as React from "react";
import * as ProgressPrimitive from "@radix-ui/react-progress";
import { cn } from "@/lib/utils";

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-2 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };

================
File: src/components/ui/radio-group.tsx
================
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }

================
File: src/components/ui/scroll-area.tsx
================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

================
File: src/components/ui/select.tsx
================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

================
File: src/components/ui/separator.tsx
================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

================
File: src/components/ui/sheet.tsx
================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

================
File: src/components/ui/skeleton.tsx
================
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }

================
File: src/components/ui/switch.tsx
================
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

================
File: src/components/ui/table.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

================
File: src/components/ui/tabs.tsx
================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

================
File: src/components/ui/textarea.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }

================
File: src/components/ui/toast.tsx
================
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

================
File: src/components/ui/toaster.tsx
================
"use client"

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

================
File: src/components/ui/tooltip.tsx
================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

================
File: src/components/mode-toggle.tsx
================
"use client"

import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"

import { Button } from "@/components/ui/button"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"

export function ModeToggle() {
  const { setTheme } = useTheme()

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}

================
File: src/emails/event-invitation.tsx
================
// src/emails/event-invitation.tsx
import {
  Body,
  Button,
  Container,
  Head,
  Heading,
  Hr,
  Html,
  Preview,
  Section,
  Text,
} from "@react-email/components";
import * as React from "react";

interface EventInvitationProps {
  eventTitle: string;
  eventDate: string;
  eventTime: string;
  location: string;
  eventUrl: string;
  personalMessage?: string;
}

const EventInvitationEmail: React.FC<EventInvitationProps> = ({
  eventTitle,
  eventDate,
  eventTime,
  location,
  eventUrl,
  personalMessage,
}) => {
  const previewText = `You're invited to ${eventTitle}!`;

  return (
    <Html>
      <Head />
      <Preview>{previewText}</Preview>
      <Body style={main}>
        <Container style={container}>
          <Heading style={h1}>{eventTitle}</Heading>
          
          <Section style={section}>
            <Text style={text}>You've been invited to join this event!</Text>
            
            {personalMessage && (
              <>
                <Text style={messageBox}>{personalMessage}</Text>
                <Hr style={hr} />
              </>
            )}
            
            <Text style={detailsTitle}>Event Details:</Text>
            <Text style={details}>
               Date: {eventDate}<br />
               Time: {eventTime}<br />
               Location: {location}
            </Text>

            <Button
              href={eventUrl}
              style={button}
            >
              View Event Details
            </Button>
          </Section>
        </Container>
      </Body>
    </Html>
  );
};

// Styles
const main = {
  backgroundColor: "#f6f9fc",
  fontFamily: '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Ubuntu,sans-serif',
};

const container = {
  backgroundColor: "#ffffff",
  margin: "0 auto",
  padding: "20px 0 48px",
  marginBottom: "64px",
};

const section = {
  padding: "0 48px",
};

const h1 = {
  color: "#333",
  fontSize: "24px",
  fontWeight: "bold",
  margin: "40px 0",
  padding: "0",
  textAlign: "center" as const,
};

const text = {
  color: "#333",
  fontSize: "16px",
  margin: "24px 0",
};

const messageBox = {
  backgroundColor: "#f9f9f9",
  border: "1px solid #ddd",
  borderRadius: "5px",
  color: "#555",
  fontSize: "16px",
  margin: "24px 0",
  padding: "16px",
};

const detailsTitle = {
  color: "#333",
  fontSize: "18px",
  fontWeight: "bold",
  margin: "24px 0 8px",
};

const details = {
  color: "#555",
  fontSize: "16px",
  lineHeight: "24px",
  margin: "0 0 24px",
};

const button = {
  backgroundColor: "#000",
  borderRadius: "5px",
  color: "#fff",
  display: "block",
  fontSize: "16px",
  fontWeight: "bold",
  textAlign: "center" as const,
  textDecoration: "none",
  padding: "12px 20px",
  margin: "32px auto",
};

const hr = {
  borderColor: "#e6ebf1",
  margin: "20px 0",
};

export default EventInvitationEmail;

================
File: src/hooks/use-error-boundary.ts
================
import { useCallback, useState } from 'react';

export function useErrorBoundary() {
  const [hasError, setHasError] = useState(false);

  const handleError = useCallback((error: Error) => {
    setHasError(true);
    // Log to your error reporting service
    console.error('Error caught by boundary:', error);
  }, []);

  const resetError = useCallback(() => {
    setHasError(false);
  }, []);

  return {
    hasError,
    handleError,
    resetError,
  };
}

================
File: src/hooks/use-feature-access.ts
================
import { useState, useCallback, Fragment, ReactNode, JSX, createElement } from "react";
import { useSubscription } from "./use-subscription";
import { Feature } from "@/types/subscription";

interface UseFeatureAccessReturn {
  checkFeature: (feature: Feature) => boolean;
  requireFeature: (feature: Feature, fallback?: ReactNode) => 
    (props: { children: ReactNode }) => JSX.Element | null;
  showUpgradeDialog: (feature: Feature) => void;
  isLoading: boolean;
}

interface FeatureGateProps {
  children: ReactNode;
}

export function useFeatureAccess(): UseFeatureAccessReturn {
  const { plan, isLoading } = useSubscription();
  const [showUpgrade, setShowUpgrade] = useState(false);
  const [requiredFeature, setRequiredFeature] = useState<Feature | null>(null);

  const checkFeature = useCallback((feature: Feature): boolean => {
    if (isLoading || !plan || !plan.limits || !plan.limits.features) {
      return false;
    }

    return plan.limits.features.includes(feature);
  }, [isLoading, plan]);

  const showUpgradeDialog = useCallback((feature: Feature) => {
    setRequiredFeature(feature);
    setShowUpgrade(true);
  }, []);

  const requireFeature = useCallback((
    feature: Feature,
    fallback: ReactNode = null
  ) => {
    return function FeatureGate({ children }: FeatureGateProps): JSX.Element | null {
      const hasFeature = checkFeature(feature);
      
      if (!hasFeature) {
        if (fallback) return createElement(Fragment, null, fallback);
        showUpgradeDialog(feature);
        return null;
      }
      
      return createElement(Fragment, null, children);
    };
  }, [checkFeature, showUpgradeDialog]);

  return {
    checkFeature,
    requireFeature,
    showUpgradeDialog,
    isLoading
  };
}

================
File: src/hooks/use-subscription.ts
================
// src/hooks/use-subscription.ts
import { useState, useEffect } from 'react';
import { 
  SUBSCRIPTION_PLANS, 
  SubscriptionTier,
  SubscriptionStatus,
  type SubscriptionData
} from '@/types/subscription';

export interface UseSubscriptionReturn {
  subscription: SubscriptionData | null;
  isLoading: boolean;
  error: Error | null;
  refresh: () => Promise<void>;
}

export function useSubscription(): UseSubscriptionReturn {
  const [data, setData] = useState<SubscriptionData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchSubscription = async () => {
    try {
      setIsLoading(true);
      const response = await fetch('/api/subscriptions');
      if (!response.ok) throw new Error('Failed to fetch subscription');
      const subscriptionData = await response.json();
      setData(subscriptionData);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Unknown error'));
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchSubscription();
  }, []);

  return {
    subscription: data,
    isLoading,
    error,
    refresh: fetchSubscription
  };
}

================
File: src/hooks/use-toast.ts
================
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: src/lib/actions/events.ts
================
'use server'

import { auth } from "@clerk/nextjs/server";
import { revalidatePath } from "next/cache";
import dbConnect from "@/lib/db/connection";
import { Event } from "@/lib/db/models/event";
import { redirect } from "next/navigation";
import { z } from "zod";

const eventSchema = z.object({
  title: z.string().min(1),
  description: z.string(),
  startDate: z.string(),
  endDate: z.string(),
  venue: z.string(),
  address: z.string(),
  capacity: z.number().min(1)
});

export async function createEvent(formData: FormData) {
  const { userId } = await auth();
  
  if (!userId) {
    throw new Error("Unauthorized");
  }

  try {
    await dbConnect();
    
    const validatedFields = eventSchema.safeParse({
      title: formData.get('title'),
      description: formData.get('description'),
      startDate: formData.get('startDate'),
      endDate: formData.get('endDate'),
      venue: formData.get('venue'),
      address: formData.get('address'),
      capacity: Number(formData.get('capacity'))
    });

    if (!validatedFields.success) {
      return {
        error: "Invalid form data"
      };
    }

    const event = await Event.create({
      ...validatedFields.data,
      location: {
        venue: validatedFields.data.venue,
        address: validatedFields.data.address,
      },
      organizerId: userId,
      status: 'draft',
      visibility: 'private'
    });

    revalidatePath('/events');
    redirect(`/events/${event._id}`);
  } catch (error) {
    return {
      error: "Failed to create event"
    };
  }
}

================
File: src/lib/activity/notifications.ts
================
// src/lib/activity/notifications.ts

import mongoose from 'mongoose';
import { pusherServer } from "@/lib/pusher";

// Define specific activity types as constants
export const ActivityTypes = {
  // Event activities
  EVENT_CREATED: 'event.created',
  EVENT_UPDATED: 'event.updated',
  EVENT_CANCELLED: 'event.cancelled',
  
  // Guest activities
  GUEST_INVITED: 'guest.invited',
  GUEST_UPDATED: 'guest.updated',
  GUEST_REGISTERED: 'guest.registered',
  GUEST_CANCELLED: 'guest.cancelled',
  GUEST_CHECKED_IN: 'guest.checked_in',
  GUEST_REMOVED: 'guest.removed',
  GUEST_WAITLISTED: 'guest.waitlisted',
  GUEST_PROMOTED: 'guest.promoted', // When moved from waitlist to attendee
  
  // Communication activities
  COMMENT_ADDED: 'comment.added',
  MESSAGE_SENT: 'message.sent',
} as const;

// Create type from constants
export type ActivityType = typeof ActivityTypes[keyof typeof ActivityTypes];

// Activity interface
export interface Activity {
  type: ActivityType;
  userId: string;
  eventId: string;
  metadata?: Record<string, any>;
  createdAt: Date;
}

// Create Mongoose Schema for activities
const activitySchema = new mongoose.Schema({
  type: {
    type: String,
    required: true,
    enum: Object.values(ActivityTypes)
  },
  userId: {
    type: String,
    required: true,
  },
  eventId: {
    type: String,
    required: true,
  },
  metadata: {
    type: Map,
    of: mongoose.Schema.Types.Mixed,
    default: {},
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
}, {
  timestamps: true,
});

// Add indexes
activitySchema.index({ type: 1, eventId: 1 });
activitySchema.index({ userId: 1, createdAt: -1 });

// Create the model
const Activity = mongoose.models.Activity || mongoose.model('Activity', activitySchema);

export async function createActivity({
  type,
  userId,
  eventId,
  metadata = {}
}: Omit<Activity, 'createdAt'>) {
  try {
    // Create activity in database
    const activity = await Activity.create({
      type,
      userId,
      eventId,
      metadata,
    });

    // Trigger real-time update via Pusher
    await pusherServer.trigger(
      `event-${eventId}`,
      'new-activity',
      {
        type,
        userId,
        metadata,
        createdAt: activity.createdAt,
      }
    );

    // Also trigger user-specific activity
    await pusherServer.trigger(
      `user-${userId}`,
      'new-activity',
      {
        type,
        eventId,
        metadata,
        createdAt: activity.createdAt,
      }
    );

    return activity;
  } catch (error) {
    console.error('Error creating activity:', error);
    throw error;
  }
}

// Helper function to format activity messages
export function formatActivityMessage(activity: Activity): string {
  const messages: Record<ActivityType, string> = {
    [ActivityTypes.EVENT_CREATED]: "created a new event",
    [ActivityTypes.EVENT_UPDATED]: "updated event details",
    [ActivityTypes.EVENT_CANCELLED]: "cancelled the event",
    [ActivityTypes.GUEST_INVITED]: "invited a new guest",
    [ActivityTypes.GUEST_UPDATED]: "updated guest details",
    [ActivityTypes.GUEST_REGISTERED]: "registered for the event",
    [ActivityTypes.GUEST_CANCELLED]: "cancelled their registration",
    [ActivityTypes.GUEST_CHECKED_IN]: "checked in to the event",
    [ActivityTypes.GUEST_REMOVED]: "removed a guest",
    [ActivityTypes.GUEST_WAITLISTED]: "joined the waitlist",
    [ActivityTypes.GUEST_PROMOTED]: "was promoted from the waitlist",
    [ActivityTypes.COMMENT_ADDED]: "added a comment",
    [ActivityTypes.MESSAGE_SENT]: "sent a message"
  };

  return messages[activity.type] || "performed an action";
}

// Export activity types for use in other files
export { Activity as ActivityModel };

================
File: src/lib/api/error-handler.ts
================
import { NextResponse } from 'next/server';
import * as Sentry from '@sentry/nextjs';

export interface ApiError extends Error {
  code?: string;
  statusCode?: number;
  data?: any;
}

export class ApiError extends Error {
  constructor(message: string, statusCode: number = 500, code?: string, data?: any) {
    super(message);
    this.name = 'ApiError';
    this.statusCode = statusCode;
    this.code = code;
    this.data = data;
  }
}

export function handleApiError(error: unknown) {
  console.error('API Error:', error);

  // Log to Sentry
  Sentry.captureException(error);

  if (error instanceof ApiError) {
    return NextResponse.json(
      {
        error: {
          message: error.message,
          code: error.code,
          data: error.data,
        },
      },
      { status: error.statusCode }
    );
  }

  // Handle unknown errors
  return NextResponse.json(
    {
      error: {
        message: 'Internal Server Error',
        code: 'INTERNAL_SERVER_ERROR',
      },
    },
    { status: 500 }
  );
}

================
File: src/lib/auth/rate-limit.ts
================
import { Redis } from 'ioredis';
import { NextResponse } from 'next/server';

const redis = new Redis(process.env.REDIS_URL || '');

interface RateLimitConfig {
  limit: number;
  window: number; // in seconds
}

const defaultConfig: RateLimitConfig = {
  limit: 100,
  window: 60
};

export async function rateLimit(
  ip: string,
  endpoint: string,
  config: RateLimitConfig = defaultConfig
) {
  const key = `rate-limit:${ip}:${endpoint}`;
  
  const requests = await redis.incr(key);
  
  if (requests === 1) {
    await redis.expire(key, config.window);
  }

  if (requests > config.limit) {
    return new NextResponse('Too Many Requests', {
      status: 429,
      headers: {
        'Retry-After': config.window.toString()
      }
    });
  }

  return null;
}

================
File: src/lib/auth/rbac.ts
================
// src/lib/auth/rbac.ts
import { auth } from "@clerk/nextjs/server";
import { User } from "@/lib/db/models/user.model";
import { UserRole, Permission, PERMISSIONS } from "./types";
import { Redis } from '@upstash/redis';

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!
});

export const rolePermissions: Record<UserRole, Permission[]> = {
  ADMIN: [{ action: '*', resource: '*' }],
  ORGANIZER: [
    { action: PERMISSIONS.EVENTS.CREATE, resource: 'event' },
    { action: PERMISSIONS.EVENTS.UPDATE, resource: 'event' },
    { action: PERMISSIONS.EVENTS.DELETE, resource: 'event' },
    { action: PERMISSIONS.EVENTS.MANAGE_GUESTS, resource: 'guests' }
  ],
  CO_HOST: [
    { action: PERMISSIONS.EVENTS.UPDATE, resource: 'event' },
    { action: PERMISSIONS.EVENTS.MANAGE_GUESTS, resource: 'guests' }
  ],
  ATTENDEE: [
    { action: PERMISSIONS.EVENTS.READ, resource: 'event' }
  ]
};

export async function getUserRole(): Promise<UserRole> {
  const { userId } = await auth();
  if (!userId) throw new Error('Unauthorized');

  // Try cache first
  const cachedRole = await redis.get(`user_role:${userId}`);
  if (cachedRole) return cachedRole as UserRole;

  // If not in cache, check database
  const user = await User.findOne({ clerkId: userId }).select('role');
  if (!user) {
    // Create user if doesn't exist
    const newUser = await User.create({
      clerkId: userId,
      role: UserRole.ATTENDEE
    });
    return newUser.role;
  }

  // Cache the role for 1 hour
  await redis.setex(`user_role:${userId}`, 3600, user.role);
  return user.role;
}

export async function hasPermission(permission: Permission): Promise<boolean> {
  try {
    const role = await getUserRole();
    const permissions = rolePermissions[role];

    return permissions.some(p => 
      (p.action === '*' && p.resource === '*') ||
      (p.action === permission.action && p.resource === permission.resource)
    );
  } catch {
    return false;
  }
}

================
File: src/lib/auth/roles.ts
================
export enum UserRole {
    ADMIN = 'ADMIN',
    ORGANIZER = 'ORGANIZER',
    CO_HOST = 'CO_HOST',
    ATTENDEE = 'ATTENDEE'
}
  
export interface Permission {
    action: string;
    resource: string;
}
  
export const rolePermissions: Record<UserRole, Permission[]> = {
    ADMIN: [
      { action: '*', resource: '*' }
    ],
    ORGANIZER: [
      { action: 'create', resource: 'event' },
      { action: 'update', resource: 'event' },
      { action: 'delete', resource: 'event' },
      { action: 'manage', resource: 'guests' },
      { action: 'export', resource: 'data' }
    ],
    CO_HOST: [
      { action: 'update', resource: 'event' },
      { action: 'manage', resource: 'guests' }
    ],
    ATTENDEE: [
      { action: 'view', resource: 'event' },
      { action: 'chat', resource: 'event' }
    ]
}

================
File: src/lib/auth/types.ts
================
export enum UserRole {
    ADMIN = 'ADMIN',
    ORGANIZER = 'ORGANIZER',
    CO_HOST = 'CO_HOST',
    ATTENDEE = 'ATTENDEE'
}
  
export interface Permission {
    action: string;
    resource: string;
}
  
export const PERMISSIONS = {
    EVENTS: {
      CREATE: 'events:create',
      READ: 'events:read',
      UPDATE: 'events:update',
      DELETE: 'events:delete',
      MANAGE_GUESTS: 'events:manage_guests'
    },
    ADMIN: {
      MANAGE_USERS: 'admin:manage_users',
      MANAGE_ROLES: 'admin:manage_roles'
    }
} as const;

================
File: src/lib/constants/event-categories.ts
================
export const EVENT_CATEGORIES = [
    "Conference",
    "Workshop",
    "Webinar",
    "Meetup",
    "Training",
    "Social",
    "Networking",
    "Other"
] as const;
  
export const EVENT_TAGS = [
    "Technology",
    "Business",
    "Education",
    "Entertainment",
    "Health",
    "Sports",
    "Art",
    "Music",
    "Science",
    "Professional Development"
] as const;
  
export type EventCategory = typeof EVENT_CATEGORIES[number];
export type EventTag = typeof EVENT_TAGS[number];

================
File: src/lib/db/models/activity.ts
================
// src/lib/db/models/activity.ts
import mongoose, { Schema, Document, Types } from "mongoose";

export interface IActivity extends Document {
  type: string;
  userId: string;
  eventId: string;
  metadata?: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}

const ActivitySchema = new Schema({
  type: {
    type: String,
    required: true,
    enum: [
      'event.created',
      'event.updated',
      'event.cancelled',
      'event.deleted',
      'guest.invited',
      'guest.confirmed',
      'guest.declined',
      'guest.checked_in',
      'guest.removed',
      'message.sent',
      'cohost.added',
      'cohost.removed',
      'settings.updated',
      'export.generated'
    ]
  },
  userId: {
    type: String,
    required: true,
    index: true
  },
  eventId: {
    type: String,
    required: true,
    index: true
  },
  metadata: {
    type: Schema.Types.Mixed,
    default: {}
  }
}, {
  timestamps: true,
  toJSON: {
    virtuals: true,
    transform: function(doc, ret) {
      ret.id = ret._id;
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

// Compound indexes for efficient querying
ActivitySchema.index({ eventId: 1, createdAt: -1 });
ActivitySchema.index({ userId: 1, createdAt: -1 });
ActivitySchema.index({ type: 1, eventId: 1 });

// Add text index for search functionality
ActivitySchema.index({
  'metadata.guestName': 'text',
  'metadata.changes': 'text'
});

// Middleware to validate metadata based on activity type
ActivitySchema.pre('save', function(next) {
  const activity = this as IActivity;
  
  // Validate metadata based on activity type
  switch (activity.type) {
    case 'event.updated':
      if (!activity.metadata?.changes) {
        return next(new Error('Event update activity requires changes in metadata'));
      }
      break;
      
    case 'guest.invited':
    case 'guest.confirmed':
    case 'guest.declined':
    case 'guest.checked_in':
    case 'guest.removed':
      if (!activity.metadata?.guestId) {
        return next(new Error('Guest-related activity requires guestId in metadata'));
      }
      break;
      
    case 'message.sent':
      if (!activity.metadata?.messageId) {
        return next(new Error('Message activity requires messageId in metadata'));
      }
      break;
  }
  
  next();
});

// Static methods
ActivitySchema.statics = {
  /**
   * Get recent activities for an event
   */
  async getRecentEventActivities(eventId: string, limit = 20) {
    return this.find({ eventId })
      .sort({ createdAt: -1 })
      .limit(limit)
      .exec();
  },

  /**
   * Get recent activities for a user
   */
  async getUserActivities(userId: string, limit = 20) {
    return this.find({ userId })
      .sort({ createdAt: -1 })
      .limit(limit)
      .exec();
  },

  /**
   * Get activities by type
   */
  async getActivitiesByType(type: string, eventId?: string) {
    const query = eventId ? { type, eventId } : { type };
    return this.find(query)
      .sort({ createdAt: -1 })
      .exec();
  },

  /**
   * Search activities
   */
  async searchActivities(searchTerm: string, eventId?: string) {
    const query = eventId 
      ? { eventId, $text: { $search: searchTerm } }
      : { $text: { $search: searchTerm } };
      
    return this.find(query)
      .sort({ score: { $meta: "textScore" } })
      .exec();
  }
};

// Instance methods
ActivitySchema.methods = {
  /**
   * Format activity message
   */
  formatMessage() {
    const messages: Record<string, string> = {
      'event.created': 'created a new event',
      'event.updated': 'updated event details',
      'event.cancelled': 'cancelled the event',
      'event.deleted': 'deleted the event',
      'guest.invited': 'invited a new guest',
      'guest.confirmed': 'confirmed attendance',
      'guest.declined': 'declined attendance',
      'guest.checked_in': 'checked in to the event',
      'guest.removed': 'removed a guest',
      'message.sent': 'sent a message',
      'cohost.added': 'added a co-host',
      'cohost.removed': 'removed a co-host',
      'settings.updated': 'updated event settings',
      'export.generated': 'generated an export'
    };

    return messages[this.type] || 'performed an action';
  }
};

// Create model
const Activity = mongoose.models.Activity || mongoose.model<IActivity>('Activity', ActivitySchema);

export { Activity };

================
File: src/lib/db/models/event.ts
================
// src/lib/db/models/event.ts
import mongoose, { Schema, Document } from "mongoose";

export interface IEvent extends Document {
  title: string;
  description: string;
  startDate: Date;
  endDate: Date;
  location: {
    venue: string;
    address: string;
    coordinates?: {
      lat: number;
      lng: number;
    };
  };
  capacity: number;
  status: "draft" | "published" | "cancelled";
  visibility: "public" | "private";
  organizerId: string;
  coHosts: string[];
  recurring?: {
    pattern: "daily" | "weekly" | "monthly";
    interval: number;
    endDate: Date;
  };
}

const EventSchema = new Schema({
  title: { type: String, required: true },
  description: { type: String, required: true },
  startDate: { type: Date, required: true },
  endDate: { type: Date, required: true },
  location: {
    venue: { type: String, required: true, default: 'No venue specified' },
    address: { type: String, required: true, default: 'No address specified' },
    coordinates: {
      lat: Number,
      lng: Number
    }
  },
  capacity: { type: Number, required: true },
  status: {
    type: String,
    enum: ["draft", "published", "cancelled"],
    default: "draft"
  },
  visibility: {
    type: String,
    enum: ["public", "private"],
    default: "private"
  },
  organizerId: { type: String, required: true },
  coHosts: [{ type: String }],
  recurring: {
    pattern: {
      type: String,
      enum: ["daily", "weekly", "monthly"]
    },
    interval: Number,
    endDate: Date
  }
}, {
  timestamps: true,
  toJSON: {
    virtuals: true,
    transform: function(doc, ret) {
      ret.id = ret._id.toString();
      delete ret._id;
      delete ret.__v;
      return ret;
    }
  }
});

// Create indexes
EventSchema.index({ organizerId: 1, startDate: -1 });
EventSchema.index({ status: 1 });
EventSchema.index({ "location?.venue": 1 });
EventSchema.index({ title: "text", description: "text" });

const Event = mongoose.models.Event || mongoose.model<IEvent>("Event", EventSchema);

export { Event };

================
File: src/lib/db/models/guest.ts
================
import mongoose from 'mongoose';

const guestSchema = new mongoose.Schema({
  eventId: { 
    type: String, 
    required: true 
  },
  userId: { 
    type: String, 
    required: true 
  },
  name: { 
    type: String, 
    required: true 
  },
  email: { 
    type: String, 
    required: true 
  },
  status: { 
    type: String, 
    enum: ['invited', 'confirmed', 'declined', 'waitlist'],
    default: 'invited' 
  },
  role: {
    type: String,
    enum: ['attendee', 'coHost', 'moderator'],
    default: 'attendee'
  },
  dietaryPreferences: [String],
  plusOne: {
    name: String,
    dietaryPreferences: [String]
  },
  checkedIn: {
    type: Boolean,
    default: false
  },
  checkedInAt: Date,
  invitedBy: String,
  invitedAt: {
    type: Date,
    default: Date.now
  },
  responseDate: Date,
  notes: String
}, {
  timestamps: true
});

// Add compound index to prevent duplicate registrations
guestSchema.index({ eventId: 1, status: 1 });
guestSchema.index({ userId: 1, eventId: 1 }, { unique: true });
guestSchema.index({ email: 1 });

export const Guest = mongoose.models.Guest || mongoose.model('Guest', guestSchema);

================
File: src/lib/db/models/message.ts
================
import mongoose from 'mongoose';

const messageSchema = new mongoose.Schema({
  eventId: {
    type: String,
    required: true
  },
  senderId: {
    type: String,
    required: true
  },
  senderName: {
    type: String,
    required: true
  },
  senderAvatar: String,
  content: {
    type: String,
    required: true
  },
  type: {
    type: String,
    enum: ['text', 'announcement', 'system'],
    default: 'text'
  },
  replyTo: {
    messageId: String,
    content: String
  },
  attachments: [{
    name: String,
    url: String,
    type: String
  }],
  readBy: [{
    userId: String,
    readAt: Date
  }]
}, {
  timestamps: true
});

messageSchema.index({ eventId: 1, createdAt: -1 });
messageSchema.index({ senderId: 1 });

export const Message = mongoose.models.Message || mongoose.model('Message', messageSchema);

================
File: src/lib/db/models/subscription.ts
================
import mongoose, { Schema, Document } from "mongoose";

export interface ISubscription extends Document {
  userId: string;
  planId: string;
  plan: 'free' | 'pro' | 'enterprise';
  status: 'active' | 'canceled' | 'past_due' | 'incomplete' | 'trialing';
  stripeCustomerId: string;
  stripeSubscriptionId: string;
  stripePriceId: string;
  currentPeriodStart: Date;
  currentPeriodEnd: Date;
  cancelAtPeriodEnd: boolean;
  trialEndsAt?: Date;
  usage: {
    eventsCreated: number;
    totalGuests: number;
    activeEvents: number;
    storageUsed: number;
    lastReset: Date;
  };
  limits: {
    maxEvents: number;
    maxGuestsPerEvent: number;
    maxStorage: number;
    maxCoHosts: number;
  };
  features: {
    customBranding: boolean;
    advancedAnalytics: boolean;
    guestMessaging: boolean;
    eventChat: boolean;
    exportData: boolean;
    recurringEvents: boolean;
    waitlist: boolean;
    checkIn: boolean;
    guestReminders: boolean;
  };
}

const SubscriptionSchema = new Schema({
  userId: {
    type: String,
    required: true,
    unique: true,
    index: true
  },
  planId: {
    type: String,
    required: true,
    default: 'free'
  },
  plan: {
    type: String,
    enum: ['FREE', 'PRO', 'BUSINESS'],
    default: 'free',
    required: true
  },
  status: {
    type: String,
    enum: ['active', 'canceled', 'past_due', 'incomplete'],
    default: 'active'
  },
  stripeCustomerId: String,
  stripeSubscriptionId: String,
  stripePriceId: String,
  currentPeriodStart: {
    type: Date,
    default: Date.now
  },
  currentPeriodEnd: {
    type: Date,
    default: Date.now
  },
  cancelAtPeriodEnd: {
    type: Boolean,
    default: false
  },
  trialEndsAt: {
    type: Date
  },
  usage: {
    eventsCreated: { type: Number, default: 0 },
    totalGuests: { type: Number, default: 0 },
    activeEvents: { type: Number, default: 0 },
    storageUsed: { type: Number, default: 0 }, // in bytes
    lastReset: { type: Date, default: Date.now }
  },
  limits: {
    maxEvents: { type: Number, default: 1 },
    maxGuestsPerEvent: { type: Number, default: 20 },
    maxStorage: { type: Number, default: 100 * 1024 * 1024 }, // 100MB in bytes
    maxCoHosts: { type: Number, default: 0 }
  },
  features: {
    customBranding: { type: Boolean, default: false },
    advancedAnalytics: { type: Boolean, default: false },
    guestMessaging: { type: Boolean, default: false },
    eventChat: { type: Boolean, default: false },
    exportData: { type: Boolean, default: false },
    recurringEvents: { type: Boolean, default: false },
    waitlist: { type: Boolean, default: false },
    checkIn: { type: Boolean, default: false },
    guestReminders: { type: Boolean, default: false }
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Add indexes for better query performance
SubscriptionSchema.index({ status: 1 });
SubscriptionSchema.index({ currentPeriodEnd: 1 });

// Add methods to check feature access
SubscriptionSchema.methods.hasFeature = function(featureName: string): boolean {
  return this.features[featureName] === true;
};

// Add methods to check usage limits
SubscriptionSchema.methods.canCreateEvent = function(): boolean {
  return this.usage.activeEvents < this.limits.maxEvents;
};

SubscriptionSchema.methods.canAddGuests = function(guestCount: number): boolean {
  return this.usage.totalGuests + guestCount <= this.limits.maxGuestsPerEvent;
};

export const Subscription = mongoose.models.Subscription || 
  mongoose.model<ISubscription>('Subscription', SubscriptionSchema);

================
File: src/lib/db/models/user.model.ts
================
import mongoose from 'mongoose';
import { UserRole } from '@/lib/auth/types';

const userSchema = new mongoose.Schema({
  clerkId: {
    type: String,
    required: true,
    unique: true
  },
  email: {
    type: String,
    required: true,
    unique: true
  },
  role: {
    type: String,
    enum: Object.values(UserRole),
    default: UserRole.ATTENDEE
  },
  permissions: [{
    type: String
  }],
  lastLogin: Date,
  apiKey: String,
  apiKeyLastUsed: Date
}, { timestamps: true });

export const User = mongoose.models.User || mongoose.model('User', userSchema);

================
File: src/lib/db/models/waitlist.ts
================
import mongoose, { Schema, Document } from "mongoose";

export interface IWaitlist extends Document {
  eventId: string;
  userId: string;
  position: number;
  joinedAt: Date;
  status: "waiting" | "promoted" | "expired";
  notificationsSent: {
    promoted?: Date;
    reminder?: Date;
  };
}

const WaitlistSchema = new Schema({
  eventId: { type: String, required: true },
  userId: { type: String, required: true },
  position: { type: Number, required: true },
  joinedAt: { type: Date, default: Date.now },
  status: {
    type: String,
    enum: ["waiting", "promoted", "expired"],
    default: "waiting"
  },
  notificationsSent: {
    promoted: Date,
    reminder: Date
  }
}, {
  timestamps: true
});

// Create compound index for unique waitlist entries
WaitlistSchema.index({ eventId: 1, userId: 1 }, { unique: true });
WaitlistSchema.index({ eventId: 1, position: 1 });

export const Waitlist = mongoose.models.Waitlist || mongoose.model<IWaitlist>("Waitlist", WaitlistSchema);

================
File: src/lib/db/utils/monitor.ts
================
import mongoose from 'mongoose';
import { analyzeQueryPerformance } from './performance';

export async function monitorDatabasePerformance(
    model: mongoose.Model<any>,
    operation: string,
    query: object
) {
    if (process.env.NODE_ENV === 'development') {
      const startTime = Date.now();
      const stats = await analyzeQueryPerformance(model, query);
      const duration = Date.now() - startTime;
  
      console.log(`
        Operation: ${operation}
        Duration: ${duration}ms
        Docs Examined: ${stats.totalDocsExamined}
        Docs Returned: ${stats.nReturned}
        Indexes Used: ${stats.indexesUsed.join(', ') || 'None'}
      `);
    }
}

================
File: src/lib/db/utils/performance.ts
================
import mongoose from 'mongoose';

interface ExecutionStats {
  executionTimeMillis: number;
  totalDocsExamined: number;
  nReturned: number;
  indexesUsed: string[];
}

export async function analyzeQueryPerformance(
  model: mongoose.Model<any>,
  query: object,
  options: object = {}
): Promise<ExecutionStats> {
  try {
    const explanation = await model.find(query, null, options)
      .explain("executionStats") as any;

    return {
      executionTimeMillis: explanation.executionStats.executionTimeMillis,
      totalDocsExamined: explanation.executionStats.totalDocsExamined,
      nReturned: explanation.executionStats.nReturned,
      indexesUsed: explanation.queryPlanner.winningPlan.inputStage?.indexName 
        ? [explanation.queryPlanner.winningPlan.inputStage.indexName]
        : []
    };
  } catch (error) {
    console.error('Query performance analysis failed:', error);
    throw error;
  }
}

================
File: src/lib/db/connection.ts
================
import mongoose from 'mongoose';

const MONGODB_URI = process.env.DATABASE_URL as string;

if (!MONGODB_URI) {
  throw new Error('Please define the DATABASE_URL environment variable inside .env');
}

interface MongooseCache {
  conn: typeof mongoose | null;
  promise: Promise<typeof mongoose> | null;
}

// Declare the type for the global mongoose property
declare global {
  var mongoose: MongooseCache | undefined;
}

let cached = global.mongoose || { conn: null, promise: null };

if (!global.mongoose) {
  global.mongoose = cached;
}

mongoose.set('autoIndex', false); // Disable in production
mongoose.set('maxTimeMS', 30000); // Set operation timeout

async function dbConnect() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
    };

    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {
      return mongoose;
    });
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}

export default dbConnect;

================
File: src/lib/email/notifications.ts
================
// src/lib/email/notifications.ts
import { Resend } from 'resend';
import EventInvitation  from '@/emails/event-invitation';
import { render } from '@react-email/render';
import React from 'react';

const resend = new Resend(process.env.RESEND_API_KEY);

export interface InvitationParams {
    recipientEmail: string;
    eventTitle: string;
    eventDate: string;
    eventTime: string;
    location: string;
    eventUrl: string;
    personalMessage?: string;
}

export async function sendEventInvitation({
    recipientEmail,
    eventTitle,
    eventDate,
    eventTime,
    location,
    eventUrl,
    personalMessage,
  }: InvitationParams) {
    try {
      // Create the email component
      const emailComponent = React.createElement(EventInvitation, {
        eventTitle,
        eventDate,
        eventTime,
        location,
        eventUrl,
        personalMessage,
      });
  
      // Render the email
      const emailHtml = render(emailComponent);
  
      const { data, error } = await resend.emails.send({
        from: 'Event Platform <events@yourdomain.com>',
        to: recipientEmail,
        subject: `You're invited to ${eventTitle}!`,
        html: (await emailHtml).toString(),
      });
  
      if (error) {
        console.error('Error sending invitation email:', error);
        throw new Error('Failed to send invitation email');
      }
  
      return data;
    } catch (error) {
      console.error('Error in sendEventInvitation:', error);
      throw error;
    }
  }

// Utility function to format date and time
export function formatDateTime(date: Date) {
  const formattedDate = date.toLocaleDateString('en-US', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });

  const formattedTime = date.toLocaleTimeString('en-US', {
    hour: 'numeric',
    minute: '2-digit',
    hour12: true,
  });

  return { formattedDate, formattedTime };
}

// Updated interfaces for other email functions
interface ReminderParams {
  recipientEmail: string;
  eventId: string;
  eventTitle: string;
  startDate: Date;
  location: string;
}

interface UpdateParams {
  recipientEmail: string;
  eventId: string;
  eventTitle: string;
  changes: string[];
}

export async function sendEventReminder({
  recipientEmail,
  eventId,
  eventTitle,
  startDate,
  location,
}: ReminderParams) {
  const { formattedDate, formattedTime } = formatDateTime(startDate);
  const eventUrl = `${process.env.NEXT_PUBLIC_APP_URL}/events/${eventId}`;

  try {
    const emailHtml = `
      <h1>Reminder: ${eventTitle} is coming up!</h1>
      <p>This is a reminder that you have an upcoming event:</p>
      <ul>
        <li>Event: ${eventTitle}</li>
        <li>Date: ${formattedDate}</li>
        <li>Time: ${formattedTime}</li>
        <li>Location: ${location}</li>
      </ul>
      <p>View event details: <a href="${eventUrl}">${eventUrl}</a></p>
    `;

    const { data, error } = await resend.emails.send({
      from: 'Event Platform <events@yourdomain.com>',
      to: recipientEmail,
      subject: `Reminder: ${eventTitle}`,
      html: emailHtml,
    });

    if (error) throw error;
    return data;
  } catch (error) {
    console.error('Error in sendEventReminder:', error);
    throw error;
  }
}

export async function sendEventUpdate({
  recipientEmail,
  eventId,
  eventTitle,
  changes,
}: UpdateParams) {
  const eventUrl = `${process.env.NEXT_PUBLIC_APP_URL}/events/${eventId}`;

  try {
    const emailHtml = `
      <h1>Event Update: ${eventTitle}</h1>
      <p>The following changes have been made to the event:</p>
      <ul>
        ${changes.map(change => `<li>${change}</li>`).join('')}
      </ul>
      <p>View updated event details: <a href="${eventUrl}">${eventUrl}</a></p>
    `;

    const { data, error } = await resend.emails.send({
      from: 'Event Platform <events@yourdomain.com>',
      to: recipientEmail,
      subject: `Event Update: ${eventTitle}`,
      html: emailHtml,
    });

    if (error) throw error;
    return data;
  } catch (error) {
    console.error('Error in sendEventUpdate:', error);
    throw error;
  }
}

================
File: src/lib/export/index.ts
================
import ExcelJS from 'exceljs';
import { saveAs } from 'file-saver';
import Papa from 'papaparse';

export async function exportToExcel(data: any[], filename: string, sheets: { name: string; columns: any[] }[]) {
  const workbook = new ExcelJS.Workbook();

  sheets.forEach(({ name, columns }) => {
    const worksheet = workbook.addWorksheet(name);
    worksheet.columns = columns;
    worksheet.addRows(data);
  });

  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  saveAs(blob, `${filename}.xlsx`);
}

export function exportToCSV(data: any[], filename: string) {
  const csv = Papa.unparse(data);
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  saveAs(blob, `${filename}.csv`);
}

================
File: src/lib/subscription/feature-gates.ts
================
import { auth } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";
import { Feature, SUBSCRIPTION_PLANS } from "@/types/subscription";
import { Subscription } from "@/lib/db/models/subscription";
import { SubscriptionTier } from "@/types/subscription";

export type FeatureGatesType = {
  max_events: Record<SubscriptionTier, number>;
  features: Record<SubscriptionTier, string[]>;
}


export const SUBSCRIPTION_FEATURES = {
  FREE: {
    maxEvents: 1,
    maxGuestsPerEvent: 20,
    features: ['basic_analytics', 'email_invites']
  },
  PRO: {
    maxEvents: 10,
    maxGuestsPerEvent: 100,
    features: ['advanced_analytics', 'custom_branding', 'export_data']
  },
  ENTERPRISE: {
    maxEvents: -1, 
    maxGuestsPerEvent: -1,
    features: ['all']
  }
};


export const FEATURE_GATES: FeatureGatesType = {
  max_events: {
    FREE: 2,
    PRO: 10,
    BUSINESS: -1
  },
  features: {
    FREE: ['basic_analytics', 'email_invites'],
    PRO: [
      'basic_analytics',
      'email_invites',
      'custom_branding',
      'advanced_analytics'
    ],
    BUSINESS: [
      'basic_analytics',
      'email_invites',
      'custom_branding',
      'advanced_analytics',
      'priority_support'
    ]
  }
};

export async function checkFeatureAccess(feature: Feature): Promise<boolean> {
  try {
    const { userId } = await auth();
    if (!userId) return false;

    const subscription = await Subscription.findOne({ userId });
    
    if (!subscription) {
      return SUBSCRIPTION_PLANS.FREE.limits.features.includes(feature);
    }

    const plan = SUBSCRIPTION_PLANS[subscription.planId as keyof typeof SUBSCRIPTION_PLANS];
    return plan.limits.features.includes(feature);
  } catch (error) {
    console.error("Error checking feature access:", error);
    return false;
  }
}

export function withFeatureAccess(feature: Feature) {
  return async function middleware(request: Request) {
    const hasAccess = await checkFeatureAccess(feature);
    
    if (!hasAccess) {
      return new NextResponse("Feature not available in your plan", { status: 403 });
    }

    return NextResponse.next();
  };
}



export function hasFeatureAccess(subscription: { plan?: string } | null, feature: string): boolean {
    if (!subscription) return false;
    const plan = subscription.plan || 'free';
    return FEATURE_GATES.features[plan as keyof typeof FEATURE_GATES.features].includes(feature);
}

================
File: src/lib/subscription/subscription-service.ts
================
import { clerkClient } from "@clerk/nextjs/server";
import dbConnect from "@/lib/db/connection";
import { Subscription } from "@/lib/db/models/subscription";
import { stripe } from "@/lib/stripe";
import { SUBSCRIPTION_PLANS } from "@/types/subscription";

interface UsageLimits {
  canCreateEvent: boolean;
  canInviteGuests: boolean;
  isWithinLimits: boolean;
}

interface SubscriptionUpdate {
  userId: string;
  planId?: string;
  plan: 'FREE' | 'PRO' | 'BUSINESS'; 
  stripeSubscriptionId?: string;
  stripeCustomerId?: string;
  stripePriceId?: string;
  status?: string;
  currentPeriodEnd?: Date;
}

// Helper function to check if usage limits are exceeded
export async function checkUsageLimits(subscription: any): Promise<UsageLimits> {
  const plan = SUBSCRIPTION_PLANS[subscription.plan as keyof typeof SUBSCRIPTION_PLANS];
  
  // Reset usage if we're in a new billing period
  if (new Date(subscription.usage.lastReset) < subscription.currentPeriodStart) {
    subscription.usage = {
      eventsCreated: 0,
      totalGuests: 0,
      lastReset: new Date()
    };
    await subscription.save();
  }

  return {
    canCreateEvent: subscription.usage.eventsCreated < plan.limits.eventsPerMonth,
    canInviteGuests: subscription.usage.totalGuests < plan.limits.guestsPerEvent,
    isWithinLimits: true
  };
}

export async function getCurrentSubscription(userId: string) {
  try {
    await dbConnect();
    
    let subscription = await Subscription.findOne({ userId });
    
    if (!subscription) {
      // Create a default subscription with a default planId
      subscription = new Subscription({
        userId,
        planId: 'price_free',
        plan: 'FREE',
        status: 'active',
        features: SUBSCRIPTION_PLANS.FREE.limits.features || [],
        limits: {
          maxEvents: SUBSCRIPTION_PLANS.FREE.limits.eventsPerMonth,
          maxGuestsPerEvent: SUBSCRIPTION_PLANS.FREE.limits.guestsPerEvent
        },
        usage: {
          eventsCreated: 0,
          totalGuests: 0,
          lastReset: new Date()
        },
        startDate: new Date(),
        currentPeriodStart: new Date(),
        currentPeriodEnd: null
      });
      await subscription.save();
    }
    
    return subscription;
  } catch (error) {
    console.error('Error getting subscription:', error);
    throw error;
  }
}

export async function createOrUpdateSubscription(userId: string, params: SubscriptionUpdate) {
  try {
    await dbConnect();
    
    // Validate required parameters
    if (!params || !params.plan) {
      throw new Error('Plan is required for subscription update');
    }

    const user = await (await clerkClient()).users.getUser(userId);    
    const plan = SUBSCRIPTION_PLANS[params.plan];

    if (!plan) {
      throw new Error(`Invalid plan selected: ${params.plan}`);
    }

    const subscriptionData = {
      userId,
      planId: params.planId,
      plan: params.plan,
      stripePriceId: params.stripePriceId,
      status: params.status || 'active',
      stripeCustomerId: params.stripeCustomerId,
      stripeSubscriptionId: params.stripeSubscriptionId,
      email: user.emailAddresses[0].emailAddress,
      currentPeriodStart: new Date(),
      currentPeriodEnd: params.currentPeriodEnd,
      features: plan.limits.features || [],
      limits: {
        maxEvents: plan.limits.eventsPerMonth,
        maxGuestsPerEvent: plan.limits.guestsPerEvent
      },
      usage: {
        eventsCreated: 0,
        totalGuests: 0,
        lastReset: new Date()
      }
    };

    const subscription = await Subscription.findOneAndUpdate(
      { userId },
      { $set: subscriptionData },
      { upsert: true, new: true }
    );

    return subscription;
  } catch (error) {
    console.error("Error updating subscription:", error);
    throw error;
  }
}

export async function updateUsage(userId: string, updates: {
  eventsCreated?: number;
  totalGuests?: number;
}) {
  try {
    await dbConnect();
    const subscription = await Subscription.findOne({ userId });
    
    if (!subscription) {
      throw new Error("No subscription found");
    }

    const updatedUsage = {
      eventsCreated: subscription.usage.eventsCreated + (updates.eventsCreated || 0),
      totalGuests: subscription.usage.totalGuests + (updates.totalGuests || 0),
      lastReset: subscription.usage.lastReset
    };

    // Check if usage would exceed limits
    const plan = SUBSCRIPTION_PLANS[subscription.plan as keyof typeof SUBSCRIPTION_PLANS];
    if (
      (updatedUsage.eventsCreated > plan.limits.eventsPerMonth) ||
      (updatedUsage.totalGuests > plan.limits.guestsPerEvent)
    ) {
      throw new Error("Usage limit exceeded");
    }

    await Subscription.updateOne(
      { userId },
      { $set: { usage: updatedUsage } }
    );

    return updatedUsage;
  } catch (error) {
    console.error("Error updating usage:", error);
    throw error;
  }
}

================
File: src/lib/subscription/usage-tracking.ts
================
import dbConnect from "@/lib/db/connection";
import { Subscription } from "@/lib/db/models/subscription";
import { SUBSCRIPTION_PLANS, SubscriptionTier } from "@/types/subscription";
import { getCurrentSubscription } from "./subscription-service";
import { Event } from "@/lib/db/models/event";

// Add type for usage tracking
interface UsageMetrics {
  eventsCreated: number;
  totalGuests: number;
  lastReset: Date;
}

export async function trackUsage(userId: string, action: 'event' | 'guest') {
    try {
      const subscription = await Subscription.findOne({ userId });
      if (!subscription) return true;
  
      // Reset usage if in new billing period
      const now = new Date();
      if (now > subscription.currentPeriodEnd) {
        subscription.usage = {
          eventsCreated: 0,
          totalGuests: 0,
          lastReset: now
        } as UsageMetrics;
      }
  
      const plan = SUBSCRIPTION_PLANS[subscription.planId as keyof typeof SUBSCRIPTION_PLANS];
      
      if (action === 'event') {
        if (plan.limits.eventsPerMonth !== -1 && 
            subscription.usage.eventsCreated >= plan.limits.eventsPerMonth) {
          return false;
        }
        subscription.usage.eventsCreated += 1;
      } else if (action === 'guest') {
        subscription.usage.totalGuests += 1;
      }
  
      await subscription.save();
      return true;
    } catch (error) {
      console.error("Error tracking usage:", error);
      return false;
    }
}

export async function trackEventCreation(userId: string): Promise<boolean> {
    try {
      await dbConnect();
      const subscription = await getCurrentSubscription(userId);
      const plan = (subscription?.plan || 'free') as SubscriptionTier;
      
      // Fix the countDocuments error by using the Mongoose model
      const eventCount = await Event.countDocuments({ 
        organizerId: userId 
      });
      
      // Fix the indexing error by ensuring plan is a valid key
      const maxEvents = FEATURE_GATES.max_events[plan];
      if (typeof maxEvents !== 'number') {
        return false;
      }
      
      return eventCount < maxEvents;
    } catch (error) {
      console.error('Error tracking event creation:', error);
      return false;
    }
}

// Add type definition for FEATURE_GATES
export type FeatureGatesType = {
  max_events: Record<SubscriptionTier, number>;
  features: Record<SubscriptionTier, string[]>;
}

// Update your feature-gates.ts file to include the type
export const FEATURE_GATES: FeatureGatesType = {
  max_events: {
    FREE: 2,
    PRO: 10,
    BUSINESS: -1
  },
  features: {
    FREE: ['basic_analytics', 'email_invites'],
    PRO: [
      'basic_analytics',
      'email_invites',
      'custom_branding',
      'advanced_analytics'
    ],
    BUSINESS: [
      'basic_analytics',
      'email_invites',
      'custom_branding',
      'advanced_analytics',
      'priority_support'
    ]
  }
};

================
File: src/lib/subscription/webhooks.ts
================
// src/lib/subscription/webhooks.ts
import { stripe } from "@/lib/stripe";
import { createOrUpdateSubscription } from "./subscription-service";
import { Subscription } from "../db/models/subscription";
import { SUBSCRIPTION_PLANS, SubscriptionTier } from "@/types/subscription";

interface StripeSubscription {
  id: string;
  customer: string;
  status: 'active' | 'canceled' | 'past_due' | 'incomplete';
  current_period_end: number;
  current_period_start: number;
  metadata: {
    userId: string;
    planId: SubscriptionTier;
  };
  items: {
    data: Array<{
      price: {
        id: string;
      };
    }>;
  };
}

export async function handleStripeWebhook(event: { type: string; data: { object: StripeSubscription } }) {
  try {
    switch (event.type) {
      case 'customer.subscription.created':
      case 'customer.subscription.updated': {
        const subscription = event.data.object;
        
        // Map Stripe subscription to our subscription model
        await createOrUpdateSubscription(
          subscription.metadata.userId,
          {
            userId: subscription.metadata.userId,
            planId: subscription.metadata.planId,
            plan: subscription.metadata.planId,
            stripeSubscriptionId: subscription.id,
            stripeCustomerId: subscription.customer,
            stripePriceId: subscription.items.data[0].price.id,
            status: subscription.status,
            currentPeriodEnd: new Date(subscription.current_period_end * 1000)
          }
        );
        break;
      }

      case 'customer.subscription.deleted': {
        const subscription = event.data.object;
        
        await Subscription.findOneAndUpdate(
          { stripeSubscriptionId: subscription.id },
          {
            $set: {
              status: 'canceled',
              currentPeriodEnd: new Date(subscription.current_period_end * 1000),
              features: SUBSCRIPTION_PLANS.FREE.limits.features, // Reset to free features
              plan: 'FREE' as SubscriptionTier,
              usage: {
                eventsCreated: 0,
                totalGuests: 0,
                lastReset: new Date()
              }
            }
          }
        );
        break;
      }

      case 'invoice.payment_failed': {
        const subscription = event.data.object;
        
        await Subscription.findOneAndUpdate(
          { stripeSubscriptionId: subscription.id },
          {
            $set: {
              status: 'past_due',
              features: [] // Remove features on payment failure
            }
          }
        );
        break;
      }

      case 'invoice.payment_succeeded': {
        const subscription = event.data.object;
        
        await Subscription.findOneAndUpdate(
          { stripeSubscriptionId: subscription.id },
          {
            $set: {
              status: 'active',
              currentPeriodEnd: new Date(subscription.current_period_end * 1000),
              usage: {
                eventsCreated: 0,
                totalGuests: 0,
                lastReset: new Date()
              }
            }
          }
        );
        break;
      }
    }
  } catch (error) {
    console.error('Error handling webhook:', error);
    throw error;
  }
}

================
File: src/lib/validation/event.ts
================
import * as z from "zod";
import { EVENT_CATEGORIES, EVENT_TAGS } from "@/lib/constants/event-categories";

export const eventFormSchema = z.object({
  title: z.string().min(2).max(100),
  description: z.string().min(10),
  startDate: z.date(),
  endDate: z.date(),
  registrationDeadline: z.date(),
  categories: z.array(z.string()).min(1, "Select at least one category"),
  tags: z.array(z.string()),
  venue: z.string().min(2),
  address: z.string().min(5),
  isVirtual: z.boolean().default(false),
  virtualLink: z.string().url().optional().nullable(),
  isHybrid: z.boolean().default(false),
  capacity: z.string().transform(Number),
  visibility: z.enum(["public", "private"]),
  recurring: z.object({
    enabled: z.boolean().default(false),
    pattern: z.enum(["daily", "weekly", "monthly"]).optional().nullable(),
    interval: z.number().optional().nullable(),
    endDate: z.date().optional().nullable(),
    daysOfWeek: z.array(z.number()).optional().nullable(),
    dayOfMonth: z.number().optional().nullable(),
  }),
  waitlist: z.object({
    enabled: z.boolean().default(false),
    maxSize: z.number().min(0).default(0),
  }),
}).refine(data => data.endDate > data.startDate, {
  message: "End date must be after start date",
  path: ["endDate"],
}).refine(data => data.registrationDeadline <= data.startDate, {
  message: "Registration deadline must be before or on the event start date",
  path: ["registrationDeadline"],
});

================
File: src/lib/validation/sanitize.ts
================
import DOMPurify from 'isomorphic-dompurify';
import { z } from 'zod';

export function sanitizeInput(input: string): string {
  return DOMPurify.sanitize(input.trim(), {
    ALLOWED_TAGS: [], // Strip all HTML tags
    ALLOWED_ATTR: [] // Strip all attributes
  });
}

// Common validation schemas
export const eventSchema = z.object({
  title: z.string()
    .min(3, 'Title must be at least 3 characters')
    .max(100, 'Title must be less than 100 characters')
    .transform(sanitizeInput),
  
  description: z.string()
    .min(10, 'Description must be at least 10 characters')
    .max(1000, 'Description must be less than 1000 characters')
    .transform(sanitizeInput),
  
  startDate: z.date()
    .min(new Date(), 'Start date must be in the future'),
  
  endDate: z.date(),
  
  location: z.object({
    venue: z.string().min(3).transform(sanitizeInput),
    address: z.string().min(5).transform(sanitizeInput),
    coordinates: z.object({
      lat: z.number(),
      lng: z.number()
    }).optional()
  }),
  
  capacity: z.number()
    .min(1, 'Capacity must be at least 1')
    .max(100000, 'Capacity must be less than 100,000'),
  
  visibility: z.enum(['public', 'private'])
}).refine(data => data.endDate > data.startDate, {
  message: "End date must be after start date",
  path: ["endDate"]
});

================
File: src/lib/auth.ts
================
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";

export const initialProfile = async () => {
  const { userId } = await auth();

  if (!userId) {
    redirect("/sign-in");
  }

  return userId;
};

================
File: src/lib/google-calendar.ts
================
import { google } from 'googleapis';
import { OAuth2Client } from 'google-auth-library';

const oauth2Client = new OAuth2Client(
  process.env.GOOGLE_CLIENT_ID,
  process.env.GOOGLE_CLIENT_SECRET,
  process.env.GOOGLE_REDIRECT_URI
);

export async function addToGoogleCalendar(event: any, accessToken: string) {
  try {
    oauth2Client.setCredentials({ access_token: accessToken });
    const calendar = google.calendar({ version: 'v3', auth: oauth2Client });

    const calendarEvent = {
      summary: event.title,
      description: event.description,
      start: {
        dateTime: event.startDate,
        timeZone: 'UTC',
      },
      end: {
        dateTime: event.endDate,
        timeZone: 'UTC',
      },
      location: `${event.location.venue}, ${event.location.address}`,
      attendees: event.guests.map((guest: any) => ({
        email: guest.email,
      })),
      reminders: {
        useDefault: false,
        overrides: [
          { method: 'email', minutes: 24 * 60 },
          { method: 'popup', minutes: 30 },
        ],
      },
    };

    const response = await calendar.events.insert({
      calendarId: 'primary',
      requestBody: calendarEvent,
      sendUpdates: 'all',
    });

    return response.data;
  } catch (error) {
    console.error('Error adding event to Google Calendar:', error);
    throw error;
  }
}

================
File: src/lib/logger.ts
================
// src/lib/logger.ts
import * as Sentry from '@sentry/nextjs';

type LogLevel = 'info' | 'warn' | 'error' | 'debug';

interface LogData {
  message: string;
  [key: string]: any;
}

class Logger {
  private context?: string;

  constructor(context?: string) {
    this.context = context;
  }

  private log(level: LogLevel, data: LogData) {
    const timestamp = new Date().toISOString();
    const logData = {
      timestamp,
      level,
      context: this.context,
      ...data,
    };

    // Console logging
    const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${
      this.context ? `[${this.context}] ` : ''
    }${data.message}`;

    switch (level) {
      case 'error':
        console.error(logMessage, data);
        Sentry.captureException(data.error || new Error(data.message), {
          extra: data,
        });
        break;
      case 'warn':
        console.warn(logMessage, data);
        Sentry.captureMessage(data.message, {
          level: 'warning',
          extra: data,
        });
        break;
      case 'info':
        console.info(logMessage, data);
        break;
      case 'debug':
        if (process.env.NODE_ENV === 'development') {
          console.debug(logMessage, data);
        }
        break;
    }
  }

  info(message: string, data: Record<string, any> = {}) {
    this.log('info', { message, ...data });
  }

  warn(message: string, data: Record<string, any> = {}) {
    this.log('warn', { message, ...data });
  }

  error(message: string, error?: Error, data: Record<string, any> = {}) {
    this.log('error', { message, error, ...data });
  }

  debug(message: string, data: Record<string, any> = {}) {
    this.log('debug', { message, ...data });
  }
}

export const logWebhookError = async (error: any, eventType: string) => {
  console.error(`Webhook Error (${eventType}):`, error);
  // Add your production logging service here (e.g., Sentry, LogRocket)
};

export const logger = new Logger();

================
File: src/lib/pusher.ts
================
import PusherServer from "pusher";
import PusherClient from "pusher-js";

export const pusherServer = new PusherServer({
  appId: process.env.PUSHER_APP_ID!,
  key: process.env.NEXT_PUBLIC_PUSHER_APP_KEY!,
  secret: process.env.PUSHER_SECRET!,
  cluster: process.env.NEXT_PUBLIC_PUSHER_CLUSTER!,
  useTLS: true,
});

export const pusherClient = new PusherClient(
  process.env.NEXT_PUBLIC_PUSHER_APP_KEY!,
  {
    cluster: process.env.NEXT_PUBLIC_PUSHER_CLUSTER!,
  }
);

================
File: src/lib/rate-limit.ts
================
import { Redis } from '@upstash/redis';
import { Ratelimit } from '@upstash/ratelimit';

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!
});

const limiter = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(10, '10 s'),
});

export async function rateLimit(identifier: string, endpoint: string) {
  const { success, limit, reset, remaining } = await limiter.limit(
    `${identifier}:${endpoint}`
  );
  
  return { success, limit, reset, remaining };
}

================
File: src/lib/stripe.ts
================
import Stripe from "stripe";
import { SubscriptionTier } from "@/types/subscription";

// Initialize Stripe with proper type checking for the secret key
if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error('STRIPE_SECRET_KEY is not defined in environment variables');
}

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: '2024-10-28.acacia', 
  typescript: true,
  appInfo: {
    name: "Feest App",
    version: "1.0.0",
  },
});

// Define strict types for helper function parameters
interface CustomerMetadata {
  userId: string;
  [key: string]: string;
}

interface CheckoutSessionParams {
  customerId: string;
  priceId: string;
  userId: string;
  planId: SubscriptionTier;
  successUrl: string;
  cancelUrl: string;
  trialDays?: number;
}

export const stripeHelpers = {
  async getOrCreateCustomer(
    userId: string, 
    email: string, 
    metadata: Partial<CustomerMetadata> = {}
  ): Promise<Stripe.Customer> {
    try {
      const customers = await stripe.customers.search({
        query: `metadata['userId']:'${userId}'`,
        limit: 1,
      });

      if (customers.data.length > 0) {
        return customers.data[0];
      }

      return await stripe.customers.create({
        email,
        metadata: {
          userId,
          ...metadata,
        },
      });
    } catch (error) {
      if (error instanceof Stripe.errors.StripeError) {
        throw new StripeError('Failed to create/get customer', error);
      }
      throw error;
    }
  },

  async createCheckoutSession({
    customerId,
    priceId,
    userId,
    planId,
    successUrl,
    cancelUrl,
    trialDays = 0,
  }: CheckoutSessionParams): Promise<Stripe.Checkout.Session> {
    try {
      return await stripe.checkout.sessions.create({
        customer: customerId,
        mode: 'subscription',
        payment_method_types: ['card'],
        line_items: [
          {
            price: priceId,
            quantity: 1,
          },
        ],
        success_url: successUrl,
        cancel_url: cancelUrl,
        subscription_data: {
          trial_period_days: trialDays,
          metadata: {
            userId,
            planId,
          },
        },
        metadata: {
          userId,
          planId,
        },
      });
    } catch (error) {
      if (error instanceof Stripe.errors.StripeError) {
        throw new StripeError('Failed to create checkout session', error);
      }
      throw error;
    }
  },

  async createBillingPortalSession(
    customerId: string, 
    returnUrl: string
  ): Promise<Stripe.BillingPortal.Session> {
    try {
      return await stripe.billingPortal.sessions.create({
        customer: customerId,
        return_url: returnUrl,
      });
    } catch (error) {
      if (error instanceof Stripe.errors.StripeError) {
        throw new StripeError('Failed to create billing portal session', error);
      }
      throw error;
    }
  },

  async getSubscription(subscriptionId: string): Promise<StripeSubscriptionWithCustomer> {
    try {
      const subscription = await stripe.subscriptions.retrieve(subscriptionId, {
        expand: ['latest_invoice', 'customer'],
      });
      return subscription as StripeSubscriptionWithCustomer;
    } catch (error) {
      if (error instanceof Stripe.errors.StripeError) {
        throw new StripeError('Failed to retrieve subscription', error);
      }
      throw error;
    }
  },

  async handleFailedPayment(subscriptionId: string, invoiceId: string): Promise<void> {
    try {
      const invoice = await stripe.invoices.retrieve(invoiceId);
      
      if (invoice.attempt_count === 1) {
        // Instead of manually setting next_payment_attempt,
        // update the subscription's collection method
        await stripe.subscriptions.update(subscriptionId, {
          collection_method: 'charge_automatically',
          payment_settings: {
            payment_method_types: ['card'],
            save_default_payment_method: 'on_subscription'
          }
        });
      } else {
        // After multiple failures, cancel the subscription
        await stripe.subscriptions.update(subscriptionId, {
          cancel_at_period_end: true,
          metadata: {
            cancellation_reason: 'payment_failure'
          }
        });
      }
    } catch (error) {
      if (error instanceof Stripe.errors.StripeError) {
        throw new StripeError('Failed to handle payment failure', error);
      }
      throw error;
    }
  },

  async retryFailedPayment(invoiceId: string): Promise<Stripe.Invoice> {
    try {
      // Use pay instead of updating next_payment_attempt
      return await stripe.invoices.pay(invoiceId, {
        payment_method: 'pm_card_visa' // Replace with actual payment method
      });
    } catch (error) {
      if (error instanceof Stripe.errors.StripeError) {
        throw new StripeError('Failed to retry payment', error);
      }
      throw error;
    }
  },

  validateWebhookSignature(
    payload: string | Buffer, 
    signature: string, 
    secret: string
  ): Stripe.Event {
    try {
      return stripe.webhooks.constructEvent(payload, signature, secret);
    } catch (error) {
      if (error instanceof Stripe.errors.StripeError) {
        throw new StripeError('Invalid webhook signature', error);
      }
      throw error;
    }
  },
};

// Type definitions
export interface StripeSubscriptionWithCustomer extends Stripe.Subscription {
  customer: Stripe.Customer;
}

export interface StripeInvoiceWithSubscription extends Stripe.Invoice {
  subscription: Stripe.Subscription;
}

// Custom error class
export class StripeError extends Error {
  constructor(
    message: string,
    public readonly stripeError: Stripe.errors.StripeError
  ) {
    super(message);
    this.name = 'StripeError';
  }
}

// Webhook event types
export const STRIPE_WEBHOOK_EVENTS = {
  SUBSCRIPTION_CREATED: 'customer.subscription.created',
  SUBSCRIPTION_UPDATED: 'customer.subscription.updated',
  SUBSCRIPTION_DELETED: 'customer.subscription.deleted',
  PAYMENT_SUCCEEDED: 'invoice.payment_succeeded',
  PAYMENT_FAILED: 'invoice.payment_failed',
  CHECKOUT_COMPLETED: 'checkout.session.completed',
} as const;

export type StripeWebhookEvent = typeof STRIPE_WEBHOOK_EVENTS[keyof typeof STRIPE_WEBHOOK_EVENTS];

================
File: src/lib/utils.ts
================
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function serializeEvent(event: any) {
  if (!event) return null;
  
  const eventObj = event.toObject ? event.toObject() : event;
  
  return {
    id: eventObj._id.toString(),
    title: eventObj.title,
    description: eventObj.description,
    startDate: new Date(eventObj.startDate).toISOString(),
    endDate: new Date(eventObj.endDate).toISOString(),
    location: {
      venue: eventObj.location?.venue || '',
      address: eventObj.location?.address || '',
      coordinates: eventObj.location?.coordinates || null,
    },
    capacity: eventObj.capacity,
    status: eventObj.status,
    visibility: eventObj.visibility,
    organizerId: eventObj.organizerId,
    coHosts: eventObj.coHosts || [],
    recurring: eventObj.recurring || null,
    createdAt: new Date(eventObj.createdAt).toISOString(),
    updatedAt: new Date(eventObj.updatedAt).toISOString(),
    attendees: {
      confirmed: 0,
      waitlist: 0,
    },
  };
}

export function formatDate(date: Date) {
  return new Intl.DateTimeFormat("en-US", {
    month: "long",
    day: "numeric",
    year: "numeric",
  }).format(date)
}

export function absoluteUrl(path: string) {
  // First, try to use environment variable
  if (process.env.NEXT_PUBLIC_APP_URL) {
    return `${process.env.NEXT_PUBLIC_APP_URL}${path}`
  }
  
  // Fallback for development/testing
  if (process.env.VERCEL_URL) {
    return `https://${process.env.VERCEL_URL}${path}`
  }
  
  // Local development fallback
  if (process.env.NODE_ENV === 'development') {
    return `http://localhost:${process.env.PORT || 3000}${path}`
  }
  
  // Final fallback
  return `https://${process.env.NEXT_PUBLIC_DOMAIN || 'localhost:3000'}${path}`
}

export function formatCurrency(amount: number) {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
  }).format(amount)
}

export function formatNumber(number: number) {
  return new Intl.NumberFormat("en-US").format(number)
}

// Stripe specific utils
export function formatStripePrice(amount: number) {
  return formatCurrency(amount / 100)
}

// Time utils
export function getTimeAgo(date: Date) {
  const seconds = Math.floor((new Date().getTime() - date.getTime()) / 1000)
  
  let interval = seconds / 31536000
  if (interval > 1) {
    return Math.floor(interval) + ' years ago'
  }
  
  interval = seconds / 2592000
  if (interval > 1) {
    return Math.floor(interval) + ' months ago'
  }
  
  interval = seconds / 86400
  if (interval > 1) {
    return Math.floor(interval) + ' days ago'
  }
  
  interval = seconds / 3600
  if (interval > 1) {
    return Math.floor(interval) + ' hours ago'
  }
  
  interval = seconds / 60
  if (interval > 1) {
    return Math.floor(interval) + ' minutes ago'
  }
  
  return Math.floor(seconds) + ' seconds ago'
}

// URL utils
export function isValidUrl(url: string) {
  try {
    new URL(url)
    return true
  } catch {
    return false
  }
}

type ObjectWithStringKeys = { [key: string]: any };

// Object utils
export function removeEmpty<T extends ObjectWithStringKeys>(obj: T): Partial<T> {
  return Object.entries(obj).reduce((acc, [key, value]) => {
    if (value === null || value === undefined || value === '') {
      return acc;
    }

    if (Array.isArray(value)) {
      const filtered = value.filter(item => item !== null && item !== undefined && item !== '');
      if (filtered.length > 0) {
        acc[key as keyof T] = filtered as T[keyof T];
      }
      return acc;
    }

    if (typeof value === 'object') {
      const cleaned = removeEmpty(value);
      if (Object.keys(cleaned).length > 0) {
        acc[key as keyof T] = cleaned as T[keyof T];
      }
      return acc;
    }

    acc[key as keyof T] = value;
    return acc;
  }, {} as Partial<T>);
}


// Array utils
export function unique<T>(array: T[]): T[] {
  return Array.from(new Set(array));
}

// String utils
export function slugify(text: string) {
  return text
    .toString()
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-')     // Replace spaces with -
    .replace(/&/g, '-and-')   // Replace & with 'and'
    .replace(/[^\w\-]+/g, '') // Remove all non-word chars
    .replace(/\-\-+/g, '-')   // Replace multiple - with single -
}

// Validation utils
export function isEmail(email: string) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
}

// Error handling utils
export function getErrorMessage(error: unknown) {
  if (error instanceof Error) return error.message
  return String(error)
}

================
File: src/mocks/browser.ts
================
import { setupWorker } from 'msw/browser';
import { handlers } from './handlers';

export const worker = setupWorker(...handlers);

================
File: src/mocks/handlers.ts
================
import { http, HttpResponse } from 'msw';

export const handlers = [
  // Events endpoints
  http.get('/api/events', async () => {
    return HttpResponse.json([
      {
        id: '1',
        title: 'Mock Conference 2024',
        description: 'A mock event for testing',
        startDate: new Date('2024-12-01'),
        endDate: new Date('2024-12-02'),
        location: {
          venue: 'Mock Venue',
          address: '123 Test Street',
        },
        capacity: 100,
        status: 'published',
        visibility: 'public',
        organizerId: 'user_123',
        coHosts: []
      }
    ]);
  }),

  // Event stats endpoint
  http.get('/api/events/stats', async () => {
    return HttpResponse.json({
      totalEvents: 10,
      upcomingEvents: 5,
      totalAttendees: 150,
      averageAttendance: 85
    });
  }),

  // Event activities endpoint
  http.get('/api/activities', async () => {
    return HttpResponse.json([
      {
        id: '1',
        type: 'event_created',
        eventId: '1',
        userId: 'user_123',
        createdAt: new Date().toISOString()
      }
    ]);
  }),

  // Guest management endpoints
  http.get('/api/events/:eventId/guests', async () => {
    return HttpResponse.json([
      {
        id: '1',
        eventId: '1',
        userId: 'guest_123',
        status: 'confirmed',
        checkedIn: false
      }
    ]);
  })
];

================
File: src/mocks/server.ts
================
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

export const server = setupServer(...handlers);

================
File: src/types/event.ts
================
interface Event {
    id: string;
    title: string;
    description: string;
    startDate: Date;
    endDate: Date;
    location: {
      address: string;
      coordinates: {
        lat: number;
        lng: number;
      };
      venue: string;
    };
    capacity: number;
    status: 'draft' | 'published' | 'cancelled';
    visibility: 'public' | 'private';
    organizerId: string;
    coHosts: string[];
    moderators: string[];
    recurring?: {
      pattern: 'daily' | 'weekly' | 'monthly';
      interval: number;
      endDate: Date;
    };
    createdAt: Date;
    updatedAt: Date;
  }

================
File: src/types/subscription.ts
================
// src/types/subscription.ts
export const FEATURES = {
    BASIC_ANALYTICS: 'basic_analytics',
    EMAIL_INVITES: 'email_invites',
    CUSTOM_BRANDING: 'custom_branding',
    ADVANCED_ANALYTICS: 'advanced_analytics',
    PRIORITY_SUPPORT: 'priority_support',
    QR_CHECKIN: 'qr_checkin',
    EXPORT_FEATURES: 'export_features',
    RECURRING_EVENTS: 'recurring_events',
    WAITLIST: 'waitlist',
    MULTI_ORGANIZER: 'multi_organizer',
    API_ACCESS: 'api_access'
  } as const;
  
  export type Feature = typeof FEATURES[keyof typeof FEATURES];
  
  export enum SubscriptionTier {
    FREE = 'FREE',
    PRO = 'PRO',
    BUSINESS = 'BUSINESS'
  }
  
  export enum SubscriptionStatus {
    INCOMPLETE = 'incomplete',
    INCOMPLETE_EXPIRED = 'incomplete_expired',
    TRIALING = 'trialing',
    ACTIVE = 'active',
    PAST_DUE = 'past_due',
    CANCELED = 'canceled',
    UNPAID = 'unpaid'
  }
  
  export interface SubscriptionPlan {
    id: SubscriptionTier;
    name: string;
    description: string;
    price: number;
    stripePriceId: string | null;
    trialDays?: number;
    status?: SubscriptionStatus;
    features: string[];
    limits: {
      eventsPerMonth: number;
      guestsPerEvent: number;
      features: Feature[];
    };
  }
  
  export type SubscriptionPlansType = {
    [K in SubscriptionTier]: Omit<SubscriptionPlan, 'id' | 'status'>;
  };
  
  export const SUBSCRIPTION_PLANS: SubscriptionPlansType = {
    [SubscriptionTier.FREE]: {
      name: 'Free',
      description: 'For individuals just getting started',
      price: 0,
      stripePriceId: null,
      trialDays: 0,
      features: ['Up to 3 events', 'Basic analytics', 'Email support'],
      limits: {
        eventsPerMonth: 3,
        guestsPerEvent: 50,
        features: [FEATURES.BASIC_ANALYTICS]
      }
    },
    [SubscriptionTier.PRO]: {
      name: 'Pro',
      description: 'For growing organizations',
      price: 29,
      stripePriceId: process.env.NEXT_PUBLIC_STRIPE_PRO_PRICE_ID || null,
      trialDays: 14,
      features: ['Up to 50 events', 'Advanced analytics', 'Priority support'],
      limits: {
        eventsPerMonth: 50,
        guestsPerEvent: 200,
        features: [
          FEATURES.BASIC_ANALYTICS,
          FEATURES.ADVANCED_ANALYTICS,
          FEATURES.EMAIL_INVITES,
          FEATURES.RECURRING_EVENTS
        ]
      }
    },
    [SubscriptionTier.BUSINESS]: {
      name: 'Business',
      description: 'For large organizations',
      price: 99,
      stripePriceId: process.env.NEXT_PUBLIC_STRIPE_BUSINESS_PRICE_ID || null,
      trialDays: 14,
      features: ['Unlimited events', 'Custom analytics', 'Dedicated support'],
      limits: {
        eventsPerMonth: Infinity,
        guestsPerEvent: Infinity,
        features: [
          FEATURES.BASIC_ANALYTICS,
          FEATURES.ADVANCED_ANALYTICS,
          FEATURES.EMAIL_INVITES,
          FEATURES.RECURRING_EVENTS,
          FEATURES.CUSTOM_BRANDING,
          FEATURES.API_ACCESS,
          FEATURES.MULTI_ORGANIZER,
          FEATURES.WAITLIST
        ]
      }
    }
  } as const;
  
  // Helper type for the subscription hook
  export interface SubscriptionData {
    plan: SubscriptionTier;
    status: SubscriptionStatus;
    stripeCustomerId?: string;
    stripeSubscriptionId?: string;
    currentPeriodEnd: Date;
    isCanceled?: boolean;
    usage: {
      eventsCreated: number;
      totalGuests: number;
      lastReset: Date;
    };
    limits: {
      maxEvents: number;
      maxGuestsPerEvent: number;
    };
  }

================
File: src/instrumentation.ts
================
import * as Sentry from "@sentry/nextjs";

export async function register() {
  if (process.env.NEXT_RUNTIME === "nodejs") {
    Sentry.init({
      dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
      tracesSampleRate: 1.0,
      debug: process.env.NODE_ENV === "development",
      integrations: [
        // Add Node.js specific integrations
        Sentry.httpIntegration(),
        Sentry.nodeContextIntegration(),
      ],
    });
  }

  if (process.env.NEXT_RUNTIME === "edge") {
    Sentry.init({
      dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
      tracesSampleRate: 1.0,
      debug: process.env.NODE_ENV === "development",
    });
  }
}

================
File: src/middleware.ts
================
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
import { NextResponse, type NextRequest } from "next/server";
import { Redis } from "@upstash/redis";
import { Ratelimit } from "@upstash/ratelimit";

// Constants
const RATE_LIMIT = 100;
const RATE_LIMIT_WINDOW = "15 m";

// Route matchers
const protectedRoutes = createRouteMatcher([
  "/dashboard(.*)",
  "/forum(.*)",
  "/events(.*)",
]);

const authRoutes = createRouteMatcher(["/sign-in(.*)", "/sign-up(.*)"]);

// Initialize Redis
const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
  cache: "no-store",
});

// Initialize rate limiter
const rateLimiter = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(100, "15 m"),
  analytics: true,
});

// Security headers
const securityHeaders = {
  "X-Content-Type-Options": "nosniff",
  "X-Frame-Options": "DENY",
  "X-XSS-Protection": "1; mode=block",
  "Referrer-Policy": "strict-origin-when-cross-origin",
  "Permissions-Policy": "camera=(), microphone=(), geolocation=()",
};

// Helper functions
async function handleRateLimit(req: NextRequest) {
  const ip = req.headers.get("x-forwarded-for") ?? "127.0.0.1";
  const { success, remaining, reset } = await rateLimiter.limit(
    `${ip}:${req.nextUrl.pathname}`,
  );

  if (!success) {
    return new NextResponse("Too Many Requests", {
      status: 429,
      headers: {
        "X-RateLimit-Limit": RATE_LIMIT.toString(),
        "X-RateLimit-Remaining": remaining.toString(),
        "X-RateLimit-Reset": reset.toString(),
      },
    });
  }
  return null;
}

async function getUserRole(userId: string) {
  const cachedRole = await redis.get(`user_role:${userId}`);
  return cachedRole || "ATTENDEE";
}

async function createSecureResponse(req: NextRequest, userId: string) {
  const requestHeaders = new Headers(req.headers);
  requestHeaders.set("x-user-id", userId);

  const userRole = await getUserRole(userId);
  requestHeaders.set("x-user-role", userRole.toString());

  const response = NextResponse.next({
    request: { headers: requestHeaders },
  });

  // Add security headers
  Object.entries(securityHeaders).forEach(([header, value]) => {
    response.headers.set(header, value);
  });

  return response;
}

// Main middleware
export default clerkMiddleware(async (auth, req) => {
  try {
    const { userId, redirectToSignIn } = await auth();

    // Check rate limit
    const rateLimitResponse = await handleRateLimit(req);
    if (rateLimitResponse) return rateLimitResponse;

    // Handle authentication
    if (!userId && protectedRoutes(req)) {
      return redirectToSignIn({
        returnBackUrl: new URL(req.url).pathname,
      });
    }

    if (userId && authRoutes(req)) {
      return Response.redirect(new URL("/dashboard", req.url));
    }

    // Add security headers and user info for authenticated requests
    if (userId) {
      return createSecureResponse(req, userId);
    }

    return NextResponse.next();
  } catch (error) {
    console.error("Middleware Error:", error);
    return new NextResponse("Internal Server Error", { status: 500 });
  }
});

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico).*)",
    "/api/:path*",
    "/(.*)",
  ],
};

================
File: .env.example
================
NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/
NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL=/
NEXT_PUBLIC_API_URL=http://localhost:3000
RESEND_API_KEY=
GOOGLE_MAPS_API_KEY=
UPLOADTHING_SECRET=
UPLOADTHING_APP_ID=

#pusher
NEXT_PUBLIC_PUSHER_APP_KEY=
NEXT_PUBLIC_PUSHER_CLUSTER=
PUSHER_APP_ID=
PUSHER_SECRET=

#senrty
NEXT_PUBLIC_SENTRY_DSN=
SENTRY_AUTH_TOKEN=
SENTRY_ORG=
SENTRY_PROJECT=

WEBHOOK_SECRET=

NEXT_PUBLIC_GOOGLE_ADS_CLIENT_ID=

UPSTASH_REDIS_REST_URL=
UPSTASH_REDIS_REST_TOKEN=


STRIPE_SECRET_KEY=
STRIPE_PRO_PRICE_ID=
STRIPE_BUSINESS_PRICE_ID=
NEXT_PUBLIC_STRIPE_KEY=


================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}

================
File: jest.config.ts
================
import type { Config } from 'jest';
import nextJest from 'next/jest';

const createJestConfig = nextJest({
  dir: './',
});

const config: Config = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
  testEnvironment: 'jest-environment-jsdom',
  moduleNameMapper: {
    '^@/components/(.*)$': '<rootDir>/src/components/$1',
    '^@/lib/(.*)$': '<rootDir>/src/lib/$1',
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.{js,jsx,ts,tsx}',
  ],
  testMatch: [
    '<rootDir>/src/**/__tests__/**/*.{js,jsx,ts,tsx}',
    '<rootDir>/src/**/*.{spec,test}.{js,jsx,ts,tsx}',
  ],
};

export default createJestConfig(config);

================
File: jest.setup.ts
================
import { beforeAll, afterEach, afterAll } from '@jest/globals';
import '@testing-library/jest-dom';
import 'whatwg-fetch';
import { server } from './src/mocks/server';

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

================
File: next.config.mjs
================
/** @type {import('next').NextConfig} */

import { withSentryConfig } from "@sentry/nextjs";

const nextConfig = {
  // Image optimization configuration
  images: {
    domains: ["res.cloudinary.com", "uploadthing.com"],
    unoptimized: process.env.NODE_ENV === "development",
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },

  // Environment variables
  env: {
    NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL,
  },

  // Security headers
  async headers() {
    return [
      {
        source: "/:path*",
        headers: [
          {
            key: "X-DNS-Prefetch-Control",
            value: "on",
          },
          {
            key: "Strict-Transport-Security",
            value: "max-age=31536000; includeSubDomains",
          },
          {
            key: "X-Frame-Options",
            value: "SAMEORIGIN",
          },
          {
            key: "X-Content-Type-Options",
            value: "nosniff",
          },
          {
            key: "X-XSS-Protection",
            value: "1; mode=block",
          },
          {
            key: "Referrer-Policy",
            value: "origin-when-cross-origin",
          },
          {
            key: "Permissions-Policy",
            value:
              "camera=(), microphone=(), geolocation=(), interest-cohort=()",
          },
        ],
      },
    ];
  },

  // Webpack configuration
  webpack: (config, { isServer, dev }) => {
    // Handle OpenTelemetry instrumentation warnings
    config.ignoreWarnings = [
      // Ignore warnings about critical dependency
      /Critical dependency: the request of a dependency is an expression/,
    ];

    // Handle external packages that need special treatment
    if (isServer) {
      config.externals = [...config.externals, "utf-8-validate", "bufferutil"];
    }

    // Handle OpenTelemetry instrumentation packages
    if (!isServer) {
      config.resolve.fallback = {
        ...config.resolve.fallback,
        perf_hooks: false,
        diagnostics_channel: false,
      };
    }

    // Enable source maps in production
    if (!dev && !isServer) {
      config.devtool = "source-map";
    }

    return config;
  },

  // Performance optimizations
  swcMinify: true,
  reactStrictMode: true,
  poweredByHeader: false,
  compress: true,
  generateEtags: true,

  // Cache optimization
  onDemandEntries: {
    maxInactiveAge: 25 * 1000,
    pagesBufferLength: 2,
  },

  // Experimental features
  experimental: {
    serverComponentsExternalPackages: ["mongoose"],
    instrumentationHook: true,
  },

  // Redirects
  async redirects() {
    return [
      {
        source: "/home",
        destination: "/",
        permanent: true,
      },
    ];
  },
};

export default withSentryConfig(
  withSentryConfig(nextConfig, {
    org: "shareflyt",
    project: "feest",
    authToken: process.env.SENTRY_AUTH_TOKEN,
    widenClientFileUpload: true,
    transpileClientSDK: true,
    tunnelRoute: "/monitoring",
    hideSourceMaps: true,
    disableLogger: true,
  }),
  {
    // For all available options, see:
    // https://github.com/getsentry/sentry-webpack-plugin#options

    org: "shareflyt",
    project: "feest",

    // Only print logs for uploading source maps in CI
    silent: !process.env.CI,

    // For all available options, see:
    // https://docs.sentry.io/platforms/javascript/guides/nextjs/manual-setup/

    // Upload a larger set of source maps for prettier stack traces (increases build time)
    widenClientFileUpload: true,

    // Uncomment to route browser requests to Sentry through a Next.js rewrite to circumvent ad-blockers.
    // This can increase your server load as well as your hosting bill.
    // Note: Check that the configured route will not match with your Next.js middleware, otherwise reporting of client-
    // side errors will fail.
    // tunnelRoute: "/monitoring",

    // Hides source maps from generated client bundles
    hideSourceMaps: true,

    // Automatically tree-shake Sentry logger statements to reduce bundle size
    disableLogger: true,

    // Enables automatic instrumentation of Vercel Cron Monitors. (Does not yet work with App Router route handlers.)
    // See the following for more information:
    // https://docs.sentry.io/product/crons/
    // https://vercel.com/docs/cron-jobs
    automaticVercelMonitors: true,
  },
);

================
File: package.json
================
{
  "name": "feest-2",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@clerk/clerk-sdk-node": "^5.0.54",
    "@clerk/nextjs": "^6.0.2",
    "@hookform/resolvers": "^3.9.1",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-popover": "^1.1.2",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.1",
    "@radix-ui/react-scroll-area": "^1.2.0",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.1",
    "@radix-ui/react-tabs": "^1.1.1",
    "@radix-ui/react-toast": "^1.2.2",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@react-email/components": "^0.0.25",
    "@react-google-maps/api": "^2.20.3",
    "@sentry/nextjs": "^8.36.0",
    "@stripe/react-stripe-js": "^2.9.0",
    "@stripe/stripe-js": "^4.10.0",
    "@tanstack/react-query": "^5.59.16",
    "@uploadthing/react": "^7.1.0",
    "@upstash/ratelimit": "^2.0.4",
    "@upstash/redis": "^1.34.3",
    "axios": "^1.7.7",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "csv-writer": "^1.6.0",
    "date-fns": "^2.30.0",
    "exceljs": "^4.4.0",
    "express-rate-limit": "^7.4.1",
    "file-saver": "^2.0.5",
    "google-auth-library": "^9.14.2",
    "googleapis": "^144.0.0",
    "ioredis": "^5.4.1",
    "isomorphic-dompurify": "^2.16.0",
    "jest": "^29.7.0",
    "lucide-react": "^0.454.0",
    "moment": "^2.30.1",
    "mongoose": "^8.7.3",
    "next": "14.2.16",
    "next-themes": "^0.3.0",
    "papaparse": "^5.4.1",
    "pusher": "^5.2.0",
    "pusher-js": "^8.4.0-rc2",
    "qrcode.react": "^4.1.0",
    "react": "^18",
    "react-big-calendar": "^1.15.0",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18",
    "react-error-boundary": "^4.1.2",
    "react-hook-form": "^7.53.1",
    "recharts": "^2.13.2",
    "resend": "^4.0.1-alpha.0",
    "socket.io-client": "^4.8.1",
    "stripe": "^17.3.1",
    "svix": "^1.37.0",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7",
    "uploadthing": "^7.2.0",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/file-saver": "^2.0.7",
    "@types/jest": "^29.5.14",
    "@types/node": "^20.17.4",
    "@types/papaparse": "^5.3.15",
    "@types/react": "^18.3.12",
    "@types/react-big-calendar": "^1.15.0",
    "@types/react-dom": "^18.3.1",
    "msw": "^2.6.0",
    "postcss": "^8",
    "prettier": "^3.3.3",
    "prettier-plugin-tailwindcss": "^0.6.8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}

================
File: postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

================
File: sentry.client.config.ts
================
// This file configures the initialization of Sentry on the client.
// The config you add here will be used whenever a users loads a page in their browser.
// https://docs.sentry.io/platforms/javascript/guides/nextjs/

import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: "https://59eb5428b67d96b6963df775a649cb96@o4508219811889152.ingest.de.sentry.io/4508246045556816",

  // Define how likely traces are sampled. Adjust this value in production, or use tracesSampler for greater control.
  tracesSampleRate: 1,

  // Setting this option to true will print useful information to the console while you're setting up Sentry.
  debug: false,
});

================
File: sentry.edge.config.ts
================
// This file configures the initialization of Sentry for edge features (middleware, edge routes, and so on).
// The config you add here will be used whenever one of the edge features is loaded.
// Note that this config is unrelated to the Vercel Edge Runtime and is also required when running locally.
// https://docs.sentry.io/platforms/javascript/guides/nextjs/

import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: "https://59eb5428b67d96b6963df775a649cb96@o4508219811889152.ingest.de.sentry.io/4508246045556816",

  // Define how likely traces are sampled. Adjust this value in production, or use tracesSampler for greater control.
  tracesSampleRate: 1,

  // Setting this option to true will print useful information to the console while you're setting up Sentry.
  debug: false,
});

================
File: sentry.server.config.ts
================
// This file configures the initialization of Sentry on the server.
// The config you add here will be used whenever the server handles a request.
// https://docs.sentry.io/platforms/javascript/guides/nextjs/

import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: "https://59eb5428b67d96b6963df775a649cb96@o4508219811889152.ingest.de.sentry.io/4508246045556816",

  // Define how likely traces are sampled. Adjust this value in production, or use tracesSampler for greater control.
  tracesSampleRate: 1,

  // Setting this option to true will print useful information to the console while you're setting up Sentry.
  debug: false,
});

================
File: service-worker.js
================
importScripts("https://js.pusher.com/beams/service-worker.js");

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

const config: Config = {
    darkMode: ["class"],
    content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "types": ["jest", "node"],
    "typeRoots": ["./node_modules/@types"],
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "**/*.test.*", "**/*.spec.*", "jest.setup.ts"]
}
